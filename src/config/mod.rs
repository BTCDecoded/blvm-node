//! Configuration management for reference-node
//!
//! Handles configuration loading, validation, and transport selection.

#[cfg(feature = "fibre")]
use crate::network::fibre;
use crate::network::transport::TransportPreference;
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;

// TOML support for configuration files

/// Module system configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleConfig {
    /// Enable module system
    #[serde(default = "default_true")]
    pub enabled: bool,

    /// Directory containing module binaries
    #[serde(default = "default_modules_dir")]
    pub modules_dir: String,

    /// Directory for module data (state, configs)
    #[serde(default = "default_modules_data_dir")]
    pub data_dir: String,

    /// Directory for IPC sockets
    #[serde(default = "default_modules_socket_dir")]
    pub socket_dir: String,

    /// List of enabled modules (empty = auto-discover all)
    #[serde(default)]
    pub enabled_modules: Vec<String>,

    /// Module-specific configuration overrides
    #[serde(default)]
    pub module_configs:
        std::collections::HashMap<String, std::collections::HashMap<String, String>>,
}

fn default_true() -> bool {
    true
}

fn default_false() -> bool {
    false
}

fn default_modules_dir() -> String {
    "modules".to_string()
}

fn default_modules_data_dir() -> String {
    "data/modules".to_string()
}

fn default_modules_socket_dir() -> String {
    "data/modules/sockets".to_string()
}

impl Default for ModuleConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            modules_dir: "modules".to_string(),
            data_dir: "data/modules".to_string(),
            socket_dir: "data/modules/sockets".to_string(),
            enabled_modules: Vec::new(),
            module_configs: std::collections::HashMap::new(),
        }
    }
}

/// Network timing and connection behavior configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkTimingConfig {
    /// Target number of peers to connect to (Bitcoin Core uses 8-125)
    #[serde(default = "default_target_peer_count")]
    pub target_peer_count: usize,

    /// Wait time before connecting to peers from database (after persistent peers)
    #[serde(default = "default_peer_connection_delay")]
    pub peer_connection_delay_seconds: u64,

    /// Minimum interval between addr message broadcasts (prevents spam)
    #[serde(default = "default_addr_relay_min_interval")]
    pub addr_relay_min_interval_seconds: u64,

    /// Maximum addresses to include in a single addr message
    #[serde(default = "default_max_addresses_per_addr_message")]
    pub max_addresses_per_addr_message: usize,

    /// Maximum addresses to fetch from DNS seeds
    #[serde(default = "default_max_addresses_from_dns")]
    pub max_addresses_from_dns: usize,
}

fn default_target_peer_count() -> usize {
    8
}

fn default_peer_connection_delay() -> u64 {
    2
}

fn default_addr_relay_min_interval() -> u64 {
    8640 // 2.4 hours
}

fn default_max_addresses_per_addr_message() -> usize {
    1000
}

fn default_max_addresses_from_dns() -> usize {
    100
}

impl Default for NetworkTimingConfig {
    fn default() -> Self {
        Self {
            target_peer_count: 8,
            peer_connection_delay_seconds: 2,
            addr_relay_min_interval_seconds: 8640,
            max_addresses_per_addr_message: 1000,
            max_addresses_from_dns: 100,
        }
    }
}

/// Request timeout configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestTimeoutConfig {
    /// Timeout for async request-response patterns (getheaders, getdata, etc.)
    #[serde(default = "default_async_request_timeout")]
    pub async_request_timeout_seconds: u64,

    /// Timeout for UTXO commitment requests
    #[serde(default = "default_utxo_commitment_timeout")]
    pub utxo_commitment_request_timeout_seconds: u64,

    /// Cleanup interval for expired pending requests
    #[serde(default = "default_request_cleanup_interval")]
    pub request_cleanup_interval_seconds: u64,

    /// Maximum age for pending requests before cleanup
    #[serde(default = "default_pending_request_max_age")]
    pub pending_request_max_age_seconds: u64,

    /// Timeout for storage operations (seconds)
    #[serde(default = "default_storage_timeout")]
    pub storage_timeout_seconds: u64,

    /// Timeout for network operations (seconds)
    #[serde(default = "default_network_timeout")]
    pub network_timeout_seconds: u64,

    /// Timeout for RPC operations (seconds)
    #[serde(default = "default_rpc_timeout")]
    pub rpc_timeout_seconds: u64,
}

fn default_async_request_timeout() -> u64 {
    300 // 5 minutes
}

fn default_utxo_commitment_timeout() -> u64 {
    30
}

fn default_request_cleanup_interval() -> u64 {
    60
}

fn default_pending_request_max_age() -> u64 {
    300 // 5 minutes
}

fn default_storage_timeout() -> u64 {
    10 // 10 seconds
}

fn default_network_timeout() -> u64 {
    30 // 30 seconds
}

fn default_rpc_timeout() -> u64 {
    60 // 60 seconds
}

impl Default for RequestTimeoutConfig {
    fn default() -> Self {
        Self {
            async_request_timeout_seconds: 300,
            utxo_commitment_request_timeout_seconds: 30,
            request_cleanup_interval_seconds: 60,
            pending_request_max_age_seconds: 300,
            storage_timeout_seconds: 10,
            network_timeout_seconds: 30,
            rpc_timeout_seconds: 60,
        }
    }
}

/// Module resource limits configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleResourceLimitsConfig {
    /// Default CPU limit for modules (percentage, 0-100)
    #[serde(default = "default_module_max_cpu_percent")]
    pub default_max_cpu_percent: u32,

    /// Default memory limit for modules (bytes)
    #[serde(default = "default_module_max_memory_bytes")]
    pub default_max_memory_bytes: u64,

    /// Default file descriptor limit
    #[serde(default = "default_module_max_file_descriptors")]
    pub default_max_file_descriptors: u32,

    /// Default child process limit
    #[serde(default = "default_module_max_child_processes")]
    pub default_max_child_processes: u32,

    /// Module startup wait time (milliseconds)
    #[serde(default = "default_module_startup_wait_millis")]
    pub module_startup_wait_millis: u64,

    /// Timeout for module socket to appear (seconds)
    #[serde(default = "default_module_socket_timeout")]
    pub module_socket_timeout_seconds: u64,

    /// Interval between socket existence checks (milliseconds)
    #[serde(default = "default_module_socket_check_interval")]
    pub module_socket_check_interval_millis: u64,

    /// Maximum attempts to check for socket
    #[serde(default = "default_module_socket_max_attempts")]
    pub module_socket_max_attempts: usize,
}

fn default_module_max_cpu_percent() -> u32 {
    50
}

fn default_module_max_memory_bytes() -> u64 {
    512 * 1024 * 1024 // 512 MB
}

fn default_module_max_file_descriptors() -> u32 {
    256
}

fn default_module_max_child_processes() -> u32 {
    10
}

fn default_module_startup_wait_millis() -> u64 {
    100
}

fn default_module_socket_timeout() -> u64 {
    5
}

fn default_module_socket_check_interval() -> u64 {
    100
}

fn default_module_socket_max_attempts() -> usize {
    50
}

impl Default for ModuleResourceLimitsConfig {
    fn default() -> Self {
        Self {
            default_max_cpu_percent: 50,
            default_max_memory_bytes: 512 * 1024 * 1024,
            default_max_file_descriptors: 256,
            default_max_child_processes: 10,
            module_startup_wait_millis: 100,
            module_socket_timeout_seconds: 5,
            module_socket_check_interval_millis: 100,
            module_socket_max_attempts: 50,
        }
    }
}

/// Node configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeConfig {
    /// Network listening address
    pub listen_addr: Option<SocketAddr>,

    /// Transport preference
    pub transport_preference: TransportPreferenceConfig,

    /// Maximum number of peers
    pub max_peers: Option<usize>,

    /// Protocol version
    pub protocol_version: Option<String>,

    /// Module system configuration
    pub modules: Option<ModuleConfig>,

    /// Stratum V2 mining configuration
    #[cfg(feature = "stratum-v2")]
    pub stratum_v2: Option<StratumV2Config>,

    /// RPC authentication configuration
    pub rpc_auth: Option<RpcAuthConfig>,

    /// Ban list sharing configuration
    pub ban_list_sharing: Option<BanListSharingConfig>,

    /// Governance message relay configuration
    #[cfg(feature = "governance")]
    pub governance: Option<GovernanceConfig>,

    /// Storage and pruning configuration
    pub storage: Option<StorageConfig>,

    /// Persistent peers (peers to connect to on startup)
    #[serde(default)]
    pub persistent_peers: Vec<SocketAddr>,

    /// Enable self-advertisement (send own address to peers)
    #[serde(default = "default_true")]
    pub enable_self_advertisement: bool,

    /// DoS protection configuration
    pub dos_protection: Option<DosProtectionConfig>,

    /// Spam-specific peer banning configuration
    pub spam_ban: Option<SpamBanConfig>,

    /// Network relay configuration
    pub relay: Option<RelayConfig>,

    /// FIBRE (Fast Internet Bitcoin Relay Engine) configuration
    #[cfg(feature = "fibre")]
    pub fibre: Option<fibre::FibreConfig>,

    /// Address database configuration
    pub address_database: Option<AddressDatabaseConfig>,

    /// Dandelion++ privacy relay configuration
    #[cfg(feature = "dandelion")]
    pub dandelion: Option<DandelionConfig>,

    /// Peer rate limiting configuration
    pub peer_rate_limiting: Option<PeerRateLimitingConfig>,

    /// Network timing and connection behavior
    pub network_timing: Option<NetworkTimingConfig>,

    /// Request timeout configuration
    pub request_timeouts: Option<RequestTimeoutConfig>,

    /// Module resource limits configuration
    pub module_resource_limits: Option<ModuleResourceLimitsConfig>,

    /// ZMQ notification configuration
    #[cfg(feature = "zmq")]
    pub zmq: Option<ZmqConfig>,

    /// Logging configuration
    pub logging: Option<LoggingConfig>,

    /// Mempool configuration
    pub mempool: Option<MempoolPolicyConfig>,

    /// RBF (Replace-By-Fee) configuration
    pub rbf: Option<RbfConfig>,

    /// Payment configuration (BIP70)
    pub payment: Option<PaymentConfig>,

    /// REST API configuration
    pub rest_api: Option<RestApiConfig>,
}

/// Transport preference configuration (serializable)
///
/// Note: This is a simplified enum for serialization. The actual TransportPreference
/// uses bitflags for all combinations. Use From trait for conversion.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum TransportPreferenceConfig {
    /// TCP-only mode (Bitcoin P2P compatible, default)
    TcpOnly,
    /// Quinn-only mode (direct QUIC)
    #[cfg(feature = "quinn")]
    QuinnOnly,
    /// Iroh-only mode (QUIC-based with NAT traversal)
    #[cfg(feature = "iroh")]
    IrohOnly,
    /// Hybrid mode (TCP + Iroh)
    #[cfg(feature = "iroh")]
    Hybrid,
    /// All transports (TCP + Quinn + Iroh)
    #[cfg(all(feature = "quinn", feature = "iroh"))]
    All,
}

impl Default for TransportPreferenceConfig {
    fn default() -> Self {
        Self::TcpOnly
    }
}

impl From<TransportPreferenceConfig> for TransportPreference {
    fn from(config: TransportPreferenceConfig) -> Self {
        match config {
            TransportPreferenceConfig::TcpOnly => TransportPreference::TCP_ONLY,
            #[cfg(feature = "quinn")]
            TransportPreferenceConfig::QuinnOnly => TransportPreference::QUINN_ONLY,
            #[cfg(feature = "iroh")]
            TransportPreferenceConfig::IrohOnly => TransportPreference::IROH_ONLY,
            #[cfg(feature = "iroh")]
            TransportPreferenceConfig::Hybrid => TransportPreference::hybrid(),
            #[cfg(all(feature = "quinn", feature = "iroh"))]
            TransportPreferenceConfig::All => TransportPreference::all_transports(),
        }
    }
}

impl Default for NodeConfig {
    fn default() -> Self {
        Self {
            listen_addr: Some("127.0.0.1:8333".parse().unwrap()),
            transport_preference: TransportPreferenceConfig::TcpOnly,
            max_peers: Some(100),
            protocol_version: Some("BitcoinV1".to_string()),
            modules: Some(ModuleConfig::default()),
            #[cfg(feature = "stratum-v2")]
            stratum_v2: None,
            rpc_auth: None,
            ban_list_sharing: None,
            #[cfg(feature = "governance")]
            governance: None,
            storage: None,
            persistent_peers: Vec::new(),
            enable_self_advertisement: true,
            dos_protection: None,
            relay: None,
            #[cfg(feature = "fibre")]
            fibre: None,
            address_database: None,
            #[cfg(feature = "dandelion")]
            dandelion: None,
            peer_rate_limiting: None,
            network_timing: None,
            request_timeouts: None,
            module_resource_limits: None,
            spam_ban: None,
            #[cfg(feature = "zmq")]
            zmq: None,
            logging: None,
            mempool: None,
            rbf: None,
            payment: None,
            rest_api: None,
        }
    }
}


/// Governance message relay configuration
#[cfg(feature = "governance")]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GovernanceConfig {
    /// Enable governance message relay (default: false)
    /// If false, governance messages are gossiped but not forwarded to bllvm-commons
    #[serde(default = "default_false")]
    pub enabled: bool,

    /// URL for bllvm-commons internal API (e.g., "http://10.0.0.2:8080")
    /// Used for forwarding P2P governance messages via VPN
    #[serde(default)]
    pub commons_url: Option<String>,

    /// API key for authenticating with bllvm-commons internal API
    /// Can also be set via COMMONS_API_KEY environment variable
    #[serde(default)]
    pub api_key: Option<String>,
}

#[cfg(feature = "governance")]
impl Default for GovernanceConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            commons_url: None,
            api_key: None,
        }
    }
}

/// Ban list sharing configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BanListSharingConfig {
    /// Enable ban list sharing
    #[serde(default = "default_true")]
    pub enabled: bool,

    /// Share mode: Immediate, Periodic, or Disabled
    #[serde(default = "default_ban_share_mode")]
    pub share_mode: BanShareMode,

    /// Periodic sharing interval in seconds (only used if share_mode is Periodic)
    #[serde(default = "default_periodic_interval")]
    pub periodic_interval_seconds: u64,

    /// Minimum ban duration to share (seconds, 0 = all)
    #[serde(default = "default_min_ban_duration")]
    pub min_ban_duration_to_share: u64,
}

/// Ban share mode
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum BanShareMode {
    /// Share immediately when auto-ban occurs
    Immediate,
    /// Share periodically (default)
    Periodic,
    /// Disabled
    Disabled,
}

fn default_ban_share_mode() -> BanShareMode {
    BanShareMode::Periodic
}

fn default_periodic_interval() -> u64 {
    300 // 5 minutes
}

fn default_min_ban_duration() -> u64 {
    3600 // 1 hour
}

impl Default for BanListSharingConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            share_mode: BanShareMode::Periodic,
            periodic_interval_seconds: 300,
            min_ban_duration_to_share: 3600,
        }
    }
}

/// RPC authentication configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RpcAuthConfig {
    /// Require authentication for RPC requests
    #[serde(default)]
    pub required: bool,

    /// Valid authentication tokens
    /// Can be loaded from:
    /// 1. Environment variable RPC_AUTH_TOKENS (comma-separated)
    /// 2. Token file (if token_file is set)
    /// 3. Config file (this field)
    #[serde(default)]
    pub tokens: Vec<String>,

    /// Path to file containing tokens (one per line)
    /// If set, tokens will be loaded from this file instead of the tokens field
    /// File should have restricted permissions (chmod 600)
    #[serde(default)]
    pub token_file: Option<String>,

    /// Valid certificate fingerprints (for certificate-based auth)
    #[serde(default)]
    pub certificates: Vec<String>,

    /// Default rate limit (burst, requests per second)
    #[serde(default = "default_rate_limit_burst")]
    pub rate_limit_burst: u32,

    #[serde(default = "default_rate_limit_rate")]
    pub rate_limit_rate: u32,
}

fn default_rate_limit_burst() -> u32 {
    100
}

fn default_rate_limit_rate() -> u32 {
    10
}

impl Default for RpcAuthConfig {
    fn default() -> Self {
        Self {
            required: false,
            tokens: Vec::new(),
            token_file: None,
            certificates: Vec::new(),
            rate_limit_burst: 100,
            rate_limit_rate: 10,
        }
    }
}

impl RpcAuthConfig {
    /// Load tokens from environment variable, token file, or config file
    /// Priority: env var > token_file > config file tokens
    ///
    /// # Returns
    /// Vector of tokens loaded from the highest priority source
    pub fn load_tokens(&self) -> anyhow::Result<Vec<String>> {
        // Use standard library directly (utils::env is just a wrapper)
        use std::env;

        // Priority 1: Environment variable (highest priority)
        if let Ok(env_tokens) = env::var("RPC_AUTH_TOKENS") {
            let tokens: Vec<String> = env_tokens
                .split(',')
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty())
                .collect();
            if !tokens.is_empty() {
                return Ok(tokens);
            }
        }

        // Priority 2: Token file
        if let Some(ref token_file) = self.token_file {
            let content = std::fs::read_to_string(token_file).map_err(|e| {
                anyhow::anyhow!("Failed to read token file {:?}: {}", token_file, e)
            })?;
            let tokens: Vec<String> = content
                .lines()
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty() && !s.starts_with('#')) // Support comments
                .collect();
            if !tokens.is_empty() {
                return Ok(tokens);
            }
        }

        // Priority 3: Config file tokens (fallback to current behavior)
        Ok(self.tokens.clone())
    }
}

impl NodeConfig {
    /// Load configuration from file (supports JSON and TOML)
    pub fn from_file(path: &std::path::Path) -> anyhow::Result<Self> {
        // Validate file permissions (warn if world-readable)
        #[cfg(unix)]
        {
            if let Ok(metadata) = std::fs::metadata(path) {
                use std::os::unix::fs::PermissionsExt;
                let permissions = metadata.permissions();
                let mode = permissions.mode();
                // Check if file is readable by others (group or world)
                if mode & 0o077 != 0 {
                    tracing::warn!(
                        "SECURITY WARNING: Configuration file {:?} is readable by others (mode: {:o}). \
                         Consider setting permissions to 600 for security. \
                         Run: chmod 600 {:?}",
                        path, mode, path
                    );
                }
            }
        }

        let content = std::fs::read_to_string(path)?;

        if path.extension().and_then(|s| s.to_str()) == Some("toml") {
            // Try TOML
            let config: NodeConfig = toml::from_str(&content)
                .map_err(|e| anyhow::anyhow!("Failed to parse TOML config: {}", e))?;
            Ok(config)
        } else {
            // Default to JSON
            let config: NodeConfig = serde_json::from_str(&content)
                .map_err(|e| anyhow::anyhow!("Failed to parse JSON config: {}", e))?;
            Ok(config)
        }
    }

    /// Load configuration from JSON file
    pub fn from_json_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let config: NodeConfig = serde_json::from_str(&content)?;
        Ok(config)
    }

    /// Load configuration from TOML file
    pub fn from_toml_file(path: &std::path::Path) -> anyhow::Result<Self> {
        let content = std::fs::read_to_string(path)?;
        let config: NodeConfig = toml::from_str(&content)
            .map_err(|e| anyhow::anyhow!("Failed to parse TOML config: {}", e))?;
        Ok(config)
    }

    /// Save configuration to JSON file
    pub fn to_json_file(&self, path: &std::path::Path) -> anyhow::Result<()> {
        let content = serde_json::to_string_pretty(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Save configuration to TOML file
    pub fn to_toml_file(&self, path: &std::path::Path) -> anyhow::Result<()> {
        let content = toml::to_string_pretty(self)
            .map_err(|e| anyhow::anyhow!("Failed to serialize TOML config: {}", e))?;
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Get transport preference
    pub fn get_transport_preference(&self) -> TransportPreference {
        self.transport_preference.into()
    }

    /// Auto-detect governance server and enable if available
    ///
    /// If `governance.commons_url` is set but `governance.enabled` is false,
    /// this will check if the server responds to a health check and auto-enable governance.
    #[cfg(feature = "governance")]
    pub async fn auto_detect_governance(&mut self) -> Result<(), anyhow::Error> {
        use reqwest::Client;
        use tracing::{debug, info};

        // Only auto-detect if governance config exists but is disabled
        if let Some(ref mut gov_config) = self.governance {
            if !gov_config.enabled {
                if let Some(ref commons_url) = gov_config.commons_url {
                    let client = Client::builder()
                        .timeout(std::time::Duration::from_secs(5))
                        .build()?;

                    let health_url = format!("{}/internal/health", commons_url);
                    debug!("Auto-detecting governance server at {}", health_url);

                    match client.get(&health_url).send().await {
                        Ok(response) if response.status().is_success() => {
                            info!("Governance server detected and responding at {}, auto-enabling governance", commons_url);
                            gov_config.enabled = true;
                        }
                        Ok(response) => {
                            debug!("Governance server at {} responded with status {}, keeping governance disabled", commons_url, response.status());
                        }
                        Err(e) => {
                            debug!("Governance server at {} not reachable: {}, keeping governance disabled", commons_url, e);
                        }
                    }
                }
            }
        }

        Ok(())
    }
}

/// Stratum V2 mining configuration
#[cfg(feature = "stratum-v2")]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StratumV2Config {
    /// Enable Stratum V2 mining
    pub enabled: bool,

    /// Pool URL for miner mode (format: "tcp://pool.example.com:3333" or "iroh://<nodeid>")
    pub pool_url: Option<String>,

    /// Listen address for server mode
    pub listen_addr: Option<SocketAddr>,

    /// Transport preference for Stratum V2 connections
    pub transport_preference: TransportPreferenceConfig,

    /// Enable merge mining
    pub merge_mining_enabled: bool,

    /// Secondary chains for merge mining
    pub secondary_chains: Vec<String>,

    /// Merge mining fee configuration
    pub merge_mining_fee: Option<MergeMiningFeeConfig>,
}

/// Merge mining fee configuration
#[cfg(feature = "stratum-v2")]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MergeMiningFeeConfig {
    /// Enable automatic fee collection (default: false)
    #[serde(default = "default_false")]
    pub enabled: bool,

    /// Fee percentage (0-100, default: 1% per whitepaper)
    #[serde(default = "default_merge_mining_fee_percentage")]
    pub fee_percentage: u8,

    /// Commons address to send fees to (required if enabled)
    pub commons_address: Option<String>,

    /// Contributor identifier (for tracking)
    pub contributor_id: Option<String>,

    /// Automatic distribution enabled (default: false, requires bllvm-commons integration)
    #[serde(default = "default_false")]
    pub auto_distribute: bool,
}

#[cfg(feature = "stratum-v2")]
fn default_merge_mining_fee_percentage() -> u8 {
    1 // 1% per whitepaper
}

#[cfg(feature = "stratum-v2")]
impl Default for StratumV2Config {
    fn default() -> Self {
        Self {
            enabled: false,
            pool_url: None,
            listen_addr: None,
            transport_preference: TransportPreferenceConfig::TcpOnly,
            merge_mining_enabled: false,
            secondary_chains: Vec::new(),
            merge_mining_fee: None,
        }
    }
}

#[cfg(feature = "stratum-v2")]
impl Default for MergeMiningFeeConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            fee_percentage: 1,
            commons_address: None,
            contributor_id: None,
            auto_distribute: false,
        }
    }
}

/// Pruning mode configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum PruningMode {
    /// No pruning (keep all blocks)
    Disabled,

    /// Normal pruning (keep recent blocks for verification)
    Normal {
        /// Keep blocks from this height onwards
        #[serde(default = "default_zero")]
        keep_from_height: u64,
        /// Keep at least this many recent blocks
        #[serde(default = "default_min_recent_blocks")]
        min_recent_blocks: u64,
    },

    /// Aggressive pruning with UTXO commitments
    /// Requires: utxo-commitments feature enabled
    Aggressive {
        /// Keep blocks from this height onwards
        #[serde(default = "default_zero")]
        keep_from_height: u64,
        /// Keep UTXO commitments for all pruned blocks
        #[serde(default = "default_true")]
        keep_commitments: bool,
        /// Keep filtered blocks (spam-filtered) for pruned range
        #[serde(default = "default_false")]
        keep_filtered_blocks: bool,
        /// Minimum blocks to keep (safety margin)
        #[serde(default = "default_min_blocks")]
        min_blocks: u64,
    },

    /// Custom pruning configuration
    Custom {
        /// Keep block headers (always required for PoW verification)
        #[serde(default = "default_true")]
        keep_headers: bool,
        /// Keep block bodies from this height onwards
        #[serde(default = "default_zero")]
        keep_bodies_from_height: u64,
        /// Keep UTXO commitments (if utxo-commitments feature enabled)
        #[serde(default = "default_false")]
        keep_commitments: bool,
        /// Keep BIP158 filters (if BIP157/158 enabled)
        #[serde(default = "default_false")]
        keep_filters: bool,
        /// Keep filtered blocks (spam-filtered)
        #[serde(default = "default_false")]
        keep_filtered_blocks: bool,
        /// Keep witness data (for SegWit verification)
        #[serde(default = "default_false")]
        keep_witnesses: bool,
        /// Keep transaction index
        #[serde(default = "default_false")]
        keep_tx_index: bool,
    },
}

fn default_zero() -> u64 {
    0
}

fn default_min_recent_blocks() -> u64 {
    288 // ~2 days at 10 min/block
}

fn default_min_blocks() -> u64 {
    144 // ~1 day at 10 min/block
}

/// Pruning configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PruningConfig {
    /// Pruning mode
    #[serde(default = "default_pruning_mode")]
    pub mode: PruningMode,

    /// Automatic pruning (prune periodically as chain grows)
    #[serde(default = "default_false")]
    pub auto_prune: bool,

    /// Automatic pruning interval (blocks)
    /// Prune every N blocks if auto_prune is enabled
    #[serde(default = "default_auto_prune_interval")]
    pub auto_prune_interval: u64,

    /// Minimum blocks to keep (safety margin)
    /// Even with aggressive pruning, keep at least this many blocks
    #[serde(default = "default_min_blocks_to_keep")]
    pub min_blocks_to_keep: u64,

    /// Prune on startup (prune old blocks when node starts)
    #[serde(default = "default_false")]
    pub prune_on_startup: bool,

    /// Allow incremental pruning during IBD (requires UTXO commitments + aggressive mode)
    /// When enabled, old blocks are pruned incrementally during sync, keeping only a window
    /// of recent blocks. This prevents the need to download the full blockchain before pruning.
    #[serde(default = "default_false")]
    pub incremental_prune_during_ibd: bool,

    /// Block window size for incremental pruning (number of recent blocks to keep)
    /// Only used when incremental_prune_during_ibd is true
    #[serde(default = "default_prune_window_size")]
    pub prune_window_size: u64,

    /// Minimum blocks before starting incremental pruning during IBD
    /// Prevents pruning too early in the sync process
    #[serde(default = "default_min_blocks_for_incremental_prune")]
    pub min_blocks_for_incremental_prune: u64,

    /// UTXO commitments integration
    #[cfg(feature = "utxo-commitments")]
    pub utxo_commitments: Option<UtxoCommitmentsPruningConfig>,

    /// BIP158 filter integration
    #[cfg(feature = "bip158")]
    pub bip158_filters: Option<Bip158PruningConfig>,
}

fn default_pruning_mode() -> PruningMode {
    PruningMode::Aggressive {
        keep_from_height: 0,
        keep_commitments: true,
        keep_filtered_blocks: false,
        min_blocks: 144, // ~1 day at 10 min/block
    }
}

fn default_auto_prune_interval() -> u64 {
    144 // Prune every ~1 day at 10 min/block
}

fn default_min_blocks_to_keep() -> u64 {
    144 // ~1 day at 10 min/block
}

fn default_prune_window_size() -> u64 {
    144 // Keep last 144 blocks (~1 day) during incremental pruning
}

fn default_min_blocks_for_incremental_prune() -> u64 {
    288 // Start incremental pruning after 288 blocks (~2 days) to ensure stability
}

impl Default for PruningConfig {
    fn default() -> Self {
        Self {
            mode: PruningMode::Aggressive {
                keep_from_height: 0,
                keep_commitments: true,
                keep_filtered_blocks: false,
                min_blocks: 144, // ~1 day at 10 min/block
            },
            auto_prune: true,         // Enable automatic pruning
            auto_prune_interval: 144, // Prune every ~1 day
            min_blocks_to_keep: 144,
            prune_on_startup: false,               // Still false for safety
            incremental_prune_during_ibd: true,    // Enable incremental pruning during IBD
            prune_window_size: 144,                // Keep sliding window of 144 blocks during IBD
            min_blocks_for_incremental_prune: 288, // Start pruning after 288 blocks (~2 days)
            #[cfg(feature = "utxo-commitments")]
            utxo_commitments: None,
            #[cfg(feature = "bip158")]
            bip158_filters: None,
        }
    }
}

/// UTXO commitments pruning configuration
#[cfg(feature = "utxo-commitments")]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UtxoCommitmentsPruningConfig {
    /// Keep UTXO commitments for pruned blocks
    #[serde(default = "default_true")]
    pub keep_commitments: bool,

    /// Keep filtered blocks (spam-filtered) for pruned range
    #[serde(default = "default_false")]
    pub keep_filtered_blocks: bool,

    /// Generate commitments before pruning (if not already generated)
    #[serde(default = "default_true")]
    pub generate_before_prune: bool,

    /// Maximum age for commitments (days, 0 = keep forever)
    #[serde(default = "default_commitment_max_age")]
    pub max_commitment_age_days: u32,
}

#[cfg(feature = "utxo-commitments")]
fn default_commitment_max_age() -> u32 {
    0 // Keep forever by default
}

#[cfg(feature = "utxo-commitments")]
impl Default for UtxoCommitmentsPruningConfig {
    fn default() -> Self {
        Self {
            keep_commitments: true,
            keep_filtered_blocks: false,
            generate_before_prune: true,
            max_commitment_age_days: 0,
        }
    }
}

/// BIP158 filter pruning configuration
#[cfg(feature = "bip158")]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Bip158PruningConfig {
    /// Keep BIP158 filters for pruned blocks
    #[serde(default = "default_true")]
    pub keep_filters: bool,

    /// Keep filter header chain (always required for verification)
    #[serde(default = "default_true")]
    pub keep_filter_headers: bool,

    /// Maximum age for filters (days, 0 = keep forever)
    #[serde(default = "default_filter_max_age")]
    pub max_filter_age_days: u32,
}

#[cfg(feature = "bip158")]
fn default_filter_max_age() -> u32 {
    0 // Keep forever by default
}

#[cfg(feature = "bip158")]
impl Default for Bip158PruningConfig {
    fn default() -> Self {
        Self {
            keep_filters: true,
            keep_filter_headers: true,
            max_filter_age_days: 0,
        }
    }
}

/// Storage configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    /// Database backend selection
    #[serde(default = "default_database_backend")]
    pub database_backend: DatabaseBackendConfig,

    /// Storage path
    #[serde(default = "default_storage_path")]
    pub data_dir: String,

    /// Pruning configuration
    pub pruning: Option<PruningConfig>,

    /// Cache sizes
    pub cache: Option<StorageCacheConfig>,

    /// Transaction indexing configuration
    #[serde(default)]
    pub indexing: Option<IndexingConfig>,

    /// Compression configuration
    #[cfg(feature = "compression")]
    pub compression: Option<CompressionConfig>,
}

/// Database backend configuration
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DatabaseBackendConfig {
    /// Use sled database (beta, fallback)
    Sled,
    /// Use redb database (default, recommended)
    Redb,
    /// Auto-select based on availability
    Auto,
}

fn default_database_backend() -> DatabaseBackendConfig {
    DatabaseBackendConfig::Auto
}

fn default_storage_path() -> String {
    "data".to_string()
}

/// Storage cache configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageCacheConfig {
    /// Block cache size (MB)
    #[serde(default = "default_block_cache_mb")]
    pub block_cache_mb: usize,

    /// UTXO cache size (MB)
    #[serde(default = "default_utxo_cache_mb")]
    pub utxo_cache_mb: usize,

    /// Header cache size (MB)
    #[serde(default = "default_header_cache_mb")]
    pub header_cache_mb: usize,
}

fn default_block_cache_mb() -> usize {
    100
}

fn default_utxo_cache_mb() -> usize {
    50
}

fn default_header_cache_mb() -> usize {
    10
}

impl Default for StorageCacheConfig {
    fn default() -> Self {
        Self {
            block_cache_mb: 100,
            utxo_cache_mb: 50,
            header_cache_mb: 10,
        }
    }
}

impl Default for StorageConfig {
    fn default() -> Self {
        Self {
            database_backend: DatabaseBackendConfig::Auto,
            data_dir: "data".to_string(),
            pruning: None,
            cache: None,
            indexing: None,
            #[cfg(feature = "compression")]
            compression: None,
        }
    }
}

/// Compression configuration for storage optimization
#[cfg(feature = "compression")]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompressionConfig {
    /// Enable block compression (30-50% storage reduction)
    #[serde(default = "default_true")]
    pub block_compression_enabled: bool,

    /// Block compression level (1-22, default: 3 = balanced)
    #[serde(default = "default_block_compression_level")]
    pub block_compression_level: u32,

    /// Enable UTXO compression (20-40% storage reduction)
    #[serde(default = "default_true")]
    pub utxo_compression_enabled: bool,

    /// UTXO compression level (1-22, default: 1 = fast, UTXO set is hot data)
    #[serde(default = "default_utxo_compression_level")]
    pub utxo_compression_level: u32,

    /// Enable witness compression (20-30% storage reduction)
    #[serde(default = "default_true")]
    pub witness_compression_enabled: bool,

    /// Witness compression level (1-22, default: 2 = balanced)
    #[serde(default = "default_witness_compression_level")]
    pub witness_compression_level: u32,
}

#[cfg(feature = "compression")]
fn default_block_compression_level() -> u32 {
    3 // Balanced: good compression with reasonable speed
}

#[cfg(feature = "compression")]
fn default_utxo_compression_level() -> u32 {
    1 // Fast: UTXO set is frequently accessed
}

#[cfg(feature = "compression")]
fn default_witness_compression_level() -> u32 {
    2 // Balanced: witness data is less frequently accessed
}

#[cfg(feature = "compression")]
impl Default for CompressionConfig {
    fn default() -> Self {
        Self {
            block_compression_enabled: true,
            block_compression_level: 3,
            utxo_compression_enabled: true,
            utxo_compression_level: 1,
            witness_compression_enabled: true,
            witness_compression_level: 2,
        }
    }
}

/// Transaction indexing configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexingConfig {
    /// Enable address indexing (script_pubkey → transactions)
    /// Increases disk usage by ~20-30% and slows block processing by 2-3x
    /// Required for wallet functionality and address-based queries
    #[serde(default)]
    pub enable_address_index: bool,

    /// Enable value range indexing (value buckets → transactions)
    /// Increases disk usage by ~5-10% and slows block processing by ~1.5x
    /// Useful for querying transactions by output value ranges
    #[serde(default)]
    pub enable_value_index: bool,

    /// Indexing strategy: eager (index immediately) or lazy (index on-demand)
    /// Eager: Better query performance, slower block processing
    /// Lazy: Faster block processing, slower first query per address
    #[serde(default = "default_indexing_strategy")]
    pub strategy: IndexingStrategy,

    /// Maximum number of addresses to index (0 = unlimited)
    /// Useful for limiting memory/disk usage on resource-constrained systems
    #[serde(default = "default_max_indexed_addresses")]
    pub max_indexed_addresses: usize,

    /// Enable index compression (reduces disk usage, increases CPU)
    #[serde(default)]
    pub enable_compression: bool,

    /// Background indexing: index in background thread (non-blocking)
    /// Improves block processing speed but requires async support
    #[serde(default)]
    pub background_indexing: bool,
}

fn default_indexing_strategy() -> IndexingStrategy {
    IndexingStrategy::Eager
}

fn default_max_indexed_addresses() -> usize {
    0 // Unlimited
}

/// Indexing strategy
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum IndexingStrategy {
    /// Index transactions immediately during block processing
    Eager,
    /// Index transactions on-demand when queried (lazy loading)
    Lazy,
}

impl Default for IndexingConfig {
    fn default() -> Self {
        Self {
            enable_address_index: false,
            enable_value_index: false,
            strategy: IndexingStrategy::Eager,
            max_indexed_addresses: 0,
            enable_compression: false,
            background_indexing: false,
        }
    }
}

impl NodeConfig {
    /// Validate configuration
    pub fn validate(&self) -> anyhow::Result<()> {
        // Validate pruning configuration
        if let Some(ref storage) = self.storage {
            if let Some(ref pruning) = storage.pruning {
                pruning.validate()?;
            }
        }

        Ok(())
    }

    /// Validate security configuration and return warnings
    ///
    /// Checks for insecure configurations that could expose the node to unauthorized access.
    /// Returns a list of warning messages that should be logged but don't prevent startup.
    ///
    /// # Arguments
    /// * `rpc_addr` - The RPC server bind address
    /// * `rest_api_addr` - Optional REST API server bind address
    ///
    /// # Returns
    /// Vector of warning messages (empty if configuration is secure)
    pub fn validate_security(
        &self,
        rpc_addr: SocketAddr,
        rest_api_addr: Option<SocketAddr>,
    ) -> Vec<String> {
        let mut warnings = Vec::new();

        // Helper to check if address is localhost
        let is_localhost =
            |addr: &SocketAddr| addr.ip().is_loopback() || addr.ip().to_string() == "127.0.0.1";

        // Check RPC authentication
        if let Some(ref rpc_auth) = self.rpc_auth {
            if !rpc_auth.required {
                // Check if binding to non-localhost
                if !is_localhost(&rpc_addr) {
                    warnings.push(format!(
                        "SECURITY WARNING: RPC server is binding to {} (non-localhost) but authentication is not required. \
                        This exposes your node to unauthorized access. Consider setting rpc_auth.required = true",
                        rpc_addr
                    ));
                }
            } else if rpc_auth.tokens.is_empty() && rpc_auth.certificates.is_empty() {
                warnings.push(
                    "SECURITY WARNING: RPC authentication is required but no tokens or certificates are configured. \
                    RPC requests will be rejected. Add tokens or certificates to rpc_auth configuration."
                        .to_string(),
                );
            }
        } else {
            // No auth config at all
            if !is_localhost(&rpc_addr) {
                warnings.push(format!(
                    "SECURITY WARNING: RPC server is binding to {} (non-localhost) without authentication. \
                    This exposes your node to unauthorized access. Consider configuring rpc_auth with required = true",
                    rpc_addr
                ));
            }
        }

        // Check REST API authentication
        if let Some(rest_addr) = rest_api_addr {
            if !is_localhost(&rest_addr) {
                if let Some(ref rpc_auth) = self.rpc_auth {
                    if !rpc_auth.required {
                        warnings.push(format!(
                            "SECURITY WARNING: REST API is binding to {} (non-localhost) but authentication is not required. \
                            This exposes your node to unauthorized access. Consider setting rpc_auth.required = true",
                            rest_addr
                        ));
                    }
                } else {
                    warnings.push(format!(
                        "SECURITY WARNING: REST API is binding to {} (non-localhost) without authentication. \
                        This exposes your node to unauthorized access. Consider configuring rpc_auth with required = true",
                        rest_addr
                    ));
                }
            }
        }

        warnings
    }
}

impl PruningConfig {
    /// Validate pruning configuration
    pub fn validate(&self) -> anyhow::Result<()> {
        // Validate aggressive mode requires utxo-commitments feature
        if let PruningMode::Aggressive { .. } = self.mode {
            #[cfg(not(feature = "utxo-commitments"))]
            {
                return Err(anyhow::anyhow!(
                    "Aggressive pruning mode requires the 'utxo-commitments' feature to be enabled. \
                    Please enable it in Cargo.toml or use Normal pruning mode instead."
                ));
            }
        }

        // Validate min_blocks_to_keep is reasonable
        if self.min_blocks_to_keep == 0 {
            return Err(anyhow::anyhow!(
                "min_blocks_to_keep must be greater than 0 for safety"
            ));
        }

        // Validate auto_prune_interval
        if self.auto_prune && self.auto_prune_interval == 0 {
            return Err(anyhow::anyhow!(
                "auto_prune_interval must be greater than 0 when auto_prune is enabled"
            ));
        }

        // Validate mode-specific settings
        match &self.mode {
            PruningMode::Normal {
                min_recent_blocks, ..
            } => {
                if *min_recent_blocks == 0 {
                    return Err(anyhow::anyhow!(
                        "min_recent_blocks must be greater than 0 in Normal pruning mode"
                    ));
                }
            }
            PruningMode::Aggressive { min_blocks, .. } => {
                if *min_blocks == 0 {
                    return Err(anyhow::anyhow!(
                        "min_blocks must be greater than 0 in Aggressive pruning mode"
                    ));
                }
            }
            PruningMode::Custom { keep_headers, .. } => {
                if !keep_headers {
                    return Err(anyhow::anyhow!(
                        "keep_headers must be true in Custom pruning mode (required for PoW verification)"
                    ));
                }
            }
            PruningMode::Disabled => {
                // No validation needed
            }
        }

        Ok(())
    }
}

/// DoS protection configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DosProtectionConfig {
    /// Maximum connections per IP per time window
    #[serde(default = "default_dos_max_connections_per_window")]
    pub max_connections_per_window: usize,

    /// Time window in seconds for connection rate limiting
    #[serde(default = "default_dos_window_seconds")]
    pub window_seconds: u64,

    /// Maximum message queue size
    #[serde(default = "default_dos_max_message_queue_size")]
    pub max_message_queue_size: usize,

    /// Maximum active connections
    #[serde(default = "default_dos_max_active_connections")]
    pub max_active_connections: usize,

    /// Auto-ban threshold (number of violations before auto-ban)
    #[serde(default = "default_dos_auto_ban_threshold")]
    pub auto_ban_threshold: usize,

    /// Default ban duration in seconds
    #[serde(default = "default_dos_ban_duration")]
    pub ban_duration_seconds: u64,
}

/// Spam-specific peer banning configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SpamBanConfig {
    /// Number of spam transactions before auto-ban
    /// Default: 10
    #[serde(default = "default_spam_ban_threshold")]
    pub spam_ban_threshold: usize,

    /// Ban duration in seconds for spam violations
    /// Default: 3600 (1 hour)
    #[serde(default = "default_spam_ban_duration")]
    pub spam_ban_duration_seconds: u64,
}

fn default_spam_ban_threshold() -> usize {
    10
}

fn default_spam_ban_duration() -> u64 {
    3600 // 1 hour
}

impl Default for SpamBanConfig {
    fn default() -> Self {
        Self {
            spam_ban_threshold: 10,
            spam_ban_duration_seconds: 3600,
        }
    }
}

fn default_dos_max_connections_per_window() -> usize {
    10
}

fn default_dos_window_seconds() -> u64 {
    60
}

fn default_dos_max_message_queue_size() -> usize {
    10000
}

fn default_dos_max_active_connections() -> usize {
    200
}

fn default_dos_auto_ban_threshold() -> usize {
    3
}

fn default_dos_ban_duration() -> u64 {
    3600 // 1 hour
}

impl Default for DosProtectionConfig {
    fn default() -> Self {
        Self {
            max_connections_per_window: 10,
            window_seconds: 60,
            max_message_queue_size: 10000,
            max_active_connections: 200,
            auto_ban_threshold: 3,
            ban_duration_seconds: 3600,
        }
    }
}

/// Network relay configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RelayConfig {
    /// Maximum age for relayed items (seconds)
    #[serde(default = "default_relay_max_age")]
    pub max_relay_age: u64,

    /// Maximum number of items to track
    #[serde(default = "default_relay_max_tracked_items")]
    pub max_tracked_items: usize,

    /// Enable block relay
    #[serde(default = "default_true")]
    pub enable_block_relay: bool,

    /// Enable transaction relay
    #[serde(default = "default_true")]
    pub enable_tx_relay: bool,

    /// Enable Dandelion++ privacy relay
    #[serde(default = "default_false")]
    pub enable_dandelion: bool,
}

fn default_relay_max_age() -> u64 {
    3600 // 1 hour
}

fn default_relay_max_tracked_items() -> usize {
    10000
}

impl Default for RelayConfig {
    fn default() -> Self {
        Self {
            max_relay_age: 3600,
            max_tracked_items: 10000,
            enable_block_relay: true,
            enable_tx_relay: true,
            enable_dandelion: false,
        }
    }
}

/// Address database configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AddressDatabaseConfig {
    /// Maximum number of addresses to store
    #[serde(default = "default_address_db_max_addresses")]
    pub max_addresses: usize,

    /// Address expiration time in seconds
    #[serde(default = "default_address_db_expiration")]
    pub expiration_seconds: u64,
}

fn default_address_db_max_addresses() -> usize {
    10000
}

fn default_address_db_expiration() -> u64 {
    24 * 60 * 60 // 24 hours
}

impl Default for AddressDatabaseConfig {
    fn default() -> Self {
        Self {
            max_addresses: 10000,
            expiration_seconds: 24 * 60 * 60,
        }
    }
}

/// Dandelion++ privacy relay configuration
#[cfg(feature = "dandelion")]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DandelionConfig {
    /// Stem phase timeout in seconds
    #[serde(default = "default_dandelion_stem_timeout")]
    pub stem_timeout_seconds: u64,

    /// Probability of fluffing at each hop (0.0 to 1.0)
    #[serde(default = "default_dandelion_fluff_probability")]
    pub fluff_probability: f64,

    /// Maximum stem hops before forced fluff
    #[serde(default = "default_dandelion_max_stem_hops")]
    pub max_stem_hops: u8,
}

#[cfg(feature = "dandelion")]
fn default_dandelion_stem_timeout() -> u64 {
    10
}

#[cfg(feature = "dandelion")]
fn default_dandelion_fluff_probability() -> f64 {
    0.1 // 10%
}

#[cfg(feature = "dandelion")]
fn default_dandelion_max_stem_hops() -> u8 {
    2
}

#[cfg(feature = "dandelion")]
impl Default for DandelionConfig {
    fn default() -> Self {
        Self {
            stem_timeout_seconds: 10,
            fluff_probability: 0.1,
            max_stem_hops: 2,
        }
    }
}

/// Peer rate limiting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeerRateLimitingConfig {
    /// Default burst size (token bucket)
    #[serde(default = "default_peer_rate_burst")]
    pub default_burst: u32,

    /// Default rate (messages per second)
    #[serde(default = "default_peer_rate_rate")]
    pub default_rate: u32,
}

fn default_peer_rate_burst() -> u32 {
    100
}

fn default_peer_rate_rate() -> u32 {
    10
}

impl Default for PeerRateLimitingConfig {
    fn default() -> Self {
        Self {
            default_burst: 100,
            default_rate: 10,
        }
    }
}

/// ZMQ notification configuration
#[cfg(feature = "zmq")]
pub use crate::zmq::ZmqConfig;

/// RBF (Replace-By-Fee) mode
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum RbfMode {
    /// RBF disabled - no replacements allowed
    Disabled,

    /// Conservative RBF - strict BIP125 rules with additional safety checks
    /// - Requires higher fee rate increase (e.g., 2x instead of 1.1x)
    /// - Longer confirmation wait before allowing replacement
    /// - Additional validation checks
    Conservative,

    /// Standard RBF - strict BIP125 compliance (default)
    /// - Standard fee rate increase requirement
    /// - Standard absolute fee bump
    /// - All BIP125 rules enforced
    Standard,

    /// Aggressive RBF - relaxed rules for miners
    /// - Lower fee rate increase threshold
    /// - Faster replacement processing
    /// - May allow package replacements
    Aggressive,
}

/// RBF (Replace-By-Fee) configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RbfConfig {
    /// RBF mode (disabled, conservative, standard, aggressive)
    #[serde(default = "default_rbf_mode")]
    pub mode: RbfMode,

    /// Minimum fee rate multiplier for replacement (e.g., 1.1 = 10% increase)
    /// Conservative: 2.0 (100% increase)
    /// Standard: 1.1 (10% increase, BIP125 minimum)
    /// Aggressive: 1.05 (5% increase)
    #[serde(default = "default_rbf_fee_rate_multiplier")]
    pub min_fee_rate_multiplier: f64,

    /// Minimum absolute fee bump in satoshis
    /// Conservative: 5000 sat
    /// Standard: 1000 sat (BIP125 MIN_RELAY_FEE)
    /// Aggressive: 500 sat
    #[serde(default = "default_rbf_min_fee_bump")]
    pub min_fee_bump_satoshis: u64,

    /// Minimum confirmations before allowing replacement (conservative only)
    /// 0 = allow immediately
    #[serde(default = "default_rbf_min_confirmations")]
    pub min_confirmations: u32,

    /// Allow package replacements (aggressive only)
    /// Package = parent + child transactions replaced together
    #[serde(default = "default_rbf_allow_packages")]
    pub allow_package_replacements: bool,

    /// Maximum number of replacements per transaction
    /// Prevents replacement spam
    #[serde(default = "default_rbf_max_replacements")]
    pub max_replacements_per_tx: u32,

    /// Replacement cooldown period (seconds)
    /// Prevents rapid-fire replacements
    #[serde(default = "default_rbf_cooldown_seconds")]
    pub cooldown_seconds: u64,
}

fn default_rbf_mode() -> RbfMode {
    RbfMode::Standard
}

fn default_rbf_fee_rate_multiplier() -> f64 {
    1.1 // Standard BIP125 minimum
}

fn default_rbf_min_fee_bump() -> u64 {
    1000 // BIP125 MIN_RELAY_FEE
}

fn default_rbf_min_confirmations() -> u32 {
    0
}

fn default_rbf_allow_packages() -> bool {
    false
}

fn default_rbf_max_replacements() -> u32 {
    10
}

fn default_rbf_cooldown_seconds() -> u64 {
    60
}

impl Default for RbfConfig {
    fn default() -> Self {
        Self {
            mode: RbfMode::Standard,
            min_fee_rate_multiplier: 1.1,
            min_fee_bump_satoshis: 1000,
            min_confirmations: 0,
            allow_package_replacements: false,
            max_replacements_per_tx: 10,
            cooldown_seconds: 60,
        }
    }
}

impl RbfConfig {
    /// Get mode-specific defaults
    pub fn with_mode(mode: RbfMode) -> Self {
        match mode {
            RbfMode::Disabled => Self {
                mode: RbfMode::Disabled,
                min_fee_rate_multiplier: f64::INFINITY, // Never allow
                min_fee_bump_satoshis: u64::MAX,
                min_confirmations: u32::MAX,
                allow_package_replacements: false,
                max_replacements_per_tx: 0,
                cooldown_seconds: u64::MAX,
            },
            RbfMode::Conservative => Self {
                mode: RbfMode::Conservative,
                min_fee_rate_multiplier: 2.0,
                min_fee_bump_satoshis: 5000,
                min_confirmations: 1,
                allow_package_replacements: false,
                max_replacements_per_tx: 3,
                cooldown_seconds: 300,
            },
            RbfMode::Standard => Self::default(),
            RbfMode::Aggressive => Self {
                mode: RbfMode::Aggressive,
                min_fee_rate_multiplier: 1.05,
                min_fee_bump_satoshis: 500,
                min_confirmations: 0,
                allow_package_replacements: true,
                max_replacements_per_tx: 10,
                cooldown_seconds: 60,
            },
        }
    }
}

/// Transaction eviction strategy
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum EvictionStrategy {
    /// Evict lowest fee rate transactions first (Bitcoin Core default)
    LowestFeeRate,

    /// Evict oldest transactions first (FIFO)
    OldestFirst,

    /// Evict largest transactions first (to free most space)
    LargestFirst,

    /// Evict transactions with no descendants first (safest)
    NoDescendantsFirst,

    /// Hybrid: Combine fee rate and age
    Hybrid,

    /// SpamFirst: Evict spam transactions first (when mempool is full)
    /// Requires spam filter to be enabled
    SpamFirst,
}

/// Mempool policy configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MempoolPolicyConfig {
    /// Maximum mempool size in megabytes
    #[serde(default = "default_max_mempool_mb")]
    pub max_mempool_mb: u64,

    /// Maximum number of transactions in mempool
    #[serde(default = "default_max_mempool_txs")]
    pub max_mempool_txs: usize,

    /// Minimum relay fee rate (satoshis per vbyte)
    #[serde(default = "default_min_relay_fee_rate")]
    pub min_relay_fee_rate: u64,

    /// Minimum transaction fee (absolute, in satoshis)
    #[serde(default = "default_min_tx_fee")]
    pub min_tx_fee: u64,

    /// Incremental relay fee (for fee bumping)
    #[serde(default = "default_incremental_relay_fee")]
    pub incremental_relay_fee: u64,

    /// Maximum ancestor count (transaction + all ancestors)
    #[serde(default = "default_max_ancestor_count")]
    pub max_ancestor_count: u32,

    /// Maximum ancestor size in vbytes
    #[serde(default = "default_max_ancestor_size")]
    pub max_ancestor_size: u64,

    /// Maximum descendant count (transaction + all descendants)
    #[serde(default = "default_max_descendant_count")]
    pub max_descendant_count: u32,

    /// Maximum descendant size in vbytes
    #[serde(default = "default_max_descendant_size")]
    pub max_descendant_size: u64,

    /// Transaction eviction strategy
    #[serde(default = "default_eviction_strategy")]
    pub eviction_strategy: EvictionStrategy,

    /// Mempool expiry time in hours
    #[serde(default = "default_mempool_expiry_hours")]
    pub mempool_expiry_hours: u64,

    /// Enable mempool persistence (survives restarts)
    #[serde(default)]
    pub persist_mempool: bool,

    /// Mempool persistence file path
    #[serde(default = "default_mempool_persistence_path")]
    pub mempool_persistence_path: String,

    /// Transaction rate limit burst size (max transactions in burst)
    /// Default: 10
    #[serde(default = "default_tx_rate_limit_burst")]
    pub tx_rate_limit_burst: u32,

    /// Transaction rate limit per second
    /// Default: 1 tx/sec
    #[serde(default = "default_tx_rate_limit_per_sec")]
    pub tx_rate_limit_per_sec: u32,

    /// Transaction byte rate limit per second (bytes per second per peer)
    /// Default: 100,000 bytes/sec (100 KB/s)
    #[serde(default = "default_tx_byte_rate_limit")]
    pub tx_byte_rate_limit: u64,

    /// Transaction byte rate limit burst size (max bytes in burst)
    /// Default: 1,000,000 bytes (1 MB)
    #[serde(default = "default_tx_byte_rate_burst")]
    pub tx_byte_rate_burst: u64,
}

fn default_max_mempool_mb() -> u64 {
    300
}

fn default_max_mempool_txs() -> usize {
    100_000
}

fn default_min_relay_fee_rate() -> u64 {
    1 // 1 sat/vB
}

fn default_min_tx_fee() -> u64 {
    1000
}

fn default_incremental_relay_fee() -> u64 {
    1000
}

fn default_max_ancestor_count() -> u32 {
    25
}

fn default_max_ancestor_size() -> u64 {
    101_000 // 101 kB (Bitcoin Core default)
}

fn default_max_descendant_count() -> u32 {
    25
}

fn default_max_descendant_size() -> u64 {
    101_000 // 101 kB (Bitcoin Core default)
}

fn default_eviction_strategy() -> EvictionStrategy {
    EvictionStrategy::LowestFeeRate
}

fn default_mempool_expiry_hours() -> u64 {
    336 // 14 days
}

fn default_mempool_persistence_path() -> String {
    "data/mempool.dat".to_string()
}

fn default_tx_rate_limit_burst() -> u32 {
    10
}

fn default_tx_rate_limit_per_sec() -> u32 {
    1
}

fn default_tx_byte_rate_limit() -> u64 {
    100_000 // 100 KB/s
}

fn default_tx_byte_rate_burst() -> u64 {
    1_000_000 // 1 MB
}

impl Default for MempoolPolicyConfig {
    fn default() -> Self {
        Self {
            max_mempool_mb: 300,
            max_mempool_txs: 100_000,
            min_relay_fee_rate: 1,
            min_tx_fee: 1000,
            incremental_relay_fee: 1000,
            max_ancestor_count: 25,
            max_ancestor_size: 101_000,
            max_descendant_count: 25,
            max_descendant_size: 101_000,
            eviction_strategy: EvictionStrategy::LowestFeeRate,
            mempool_expiry_hours: 336,
            persist_mempool: false,
            mempool_persistence_path: "data/mempool.dat".to_string(),
            tx_rate_limit_burst: 10,
            tx_rate_limit_per_sec: 1,
            tx_byte_rate_limit: 100_000,
            tx_byte_rate_burst: 1_000_000,
        }
    }
}

/// Payment configuration (BIP70)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaymentConfig {
    /// Enable P2P BIP70 (default: true)
    #[serde(default = "default_true")]
    pub p2p_enabled: bool,

    /// Enable HTTP BIP70 (default: false, requires bip70-http feature)
    #[serde(default = "default_false")]
    pub http_enabled: bool,

    /// Network (mainnet, testnet, regtest, signet) - defaults to mainnet
    #[serde(default = "default_network")]
    pub network: Option<String>,

    /// Merchant private key for signing (optional, hex-encoded)
    #[serde(default)]
    pub merchant_key: Option<String>,

    /// Node payment address/script for module downloads (optional)
    /// Used when serving modules that require payment
    #[serde(default)]
    pub node_payment_address: Option<String>,

    /// Payment request storage path
    #[serde(default = "default_payment_store_path")]
    pub payment_store_path: String,

    /// Enable module payment integration (default: true)
    #[serde(default = "default_true")]
    pub module_payments_enabled: bool,
}

fn default_payment_store_path() -> String {
    "data/payments".to_string()
}

fn default_network() -> Option<String> {
    Some("mainnet".to_string())
}

impl Default for PaymentConfig {
    fn default() -> Self {
        Self {
            p2p_enabled: true,
            http_enabled: false,
            network: default_network(),
            merchant_key: None,
            node_payment_address: None,
            payment_store_path: "data/payments".to_string(),
            module_payments_enabled: true,
        }
    }
}

/// REST API configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct RestApiConfig {
    /// Enable REST API (default: false, requires rest-api feature)
    #[serde(default = "default_false")]
    pub enabled: bool,

    /// Enable payment endpoints (default: false, requires bip70-http feature)
    #[serde(default = "default_false")]
    pub payment_endpoints_enabled: bool,
}

/// Logging configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct LoggingConfig {
    /// Log level filter (e.g., "info", "debug", "blvm_node=debug,network=trace")
    /// If not set, uses RUST_LOG environment variable or defaults to "info"
    #[serde(default)]
    pub filter: Option<String>,

    /// Enable JSON logging format (for log aggregation systems)
    #[serde(default)]
    pub json_format: bool,
}
