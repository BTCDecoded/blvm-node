name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [published]
  repository_dispatch:
    types: [upstream-changed]
  workflow_dispatch:
    inputs:
      skip_verification:
        description: 'Skip Kani verification and attestation steps'
        required: false
        type: boolean
        default: false
      skip_tests:
        description: 'Skip test execution and coverage steps'
        required: false
        type: boolean
        default: false
      run_proof_tier:
        description: 'Run additional proof tier (strong always runs; choose: fast, fast_medium, or all)'
        required: false
        type: choice
        options:
          - ''
          - fast
          - fast_medium
          - all
        default: ''

permissions:
  contents: read
  actions: read

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: '1'
  CARGO_INCREMENTAL: '1'

jobs:
  setup:
    name: Setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]')))
    outputs:
      cache-key: ${{ steps.setup-cache.outputs.cache-key }}
      consensus-cache-key: ${{ steps.setup-cache.outputs.consensus-cache-key }}
      protocol-cache-key: ${{ steps.setup-cache.outputs.protocol-cache-key }}
    steps:
      - name: Disk check
        run: |
          df -h
          if [ $(df / | tail -1 | awk '{print $5}' | sed 's/%//') -gt 80 ]; then
            find /tmp/runner-cache -maxdepth 2 -type d -mtime +7 -exec rm -rf {} + 2>/dev/null || true
            df -h
          fi

      - uses: actions/checkout@v4
      
      - name: Checkout bllvm-protocol dependency (for cache key generation)
        uses: actions/checkout@v4
        with:
          repository: BTCDecoded/bllvm-protocol
          path: _temp-protocol-engine
      
      - name: Checkout consensus (for cache key generation)
        uses: actions/checkout@v4
        with:
          repository: BTCDecoded/bllvm-consensus
          path: _temp-consensus-proof
      
      - name: Cache
        id: setup-cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          
          # Generate cache keys from Cargo.lock hashes (using temp directories)
          DEPS_KEY=$(sha256sum Cargo.lock | cut -d' ' -f1)
          CONSENSUS_DEPS_KEY=$(sha256sum _temp-consensus-proof/Cargo.lock | cut -d' ' -f1)
          PROTOCOL_DEPS_KEY=$(sha256sum _temp-protocol-engine/Cargo.lock | cut -d' ' -f1)
          
          # Include toolchain version in cache key
          TOOLCHAIN=$(grep -E '^channel|rust-version' rust-toolchain.toml Cargo.toml 2>/dev/null | head -1 | sha256sum | cut -d' ' -f1 || echo "1.88.0")
          
          CACHE_KEY="${DEPS_KEY}-${TOOLCHAIN}"
          CONSENSUS_CACHE_KEY="${CONSENSUS_DEPS_KEY}-${TOOLCHAIN}"
          PROTOCOL_CACHE_KEY="${PROTOCOL_DEPS_KEY}-${TOOLCHAIN}"
          
          # Set up cache directories
          CARGO_CACHE_DIR="$CACHE_ROOT/cargo/$CACHE_KEY"
          TARGET_CACHE_DIR="$CACHE_ROOT/target/$CACHE_KEY"
          CONSENSUS_TARGET_DIR="$CACHE_ROOT/bllvm-consensus-target/$CONSENSUS_CACHE_KEY"
          PROTOCOL_TARGET_DIR="$CACHE_ROOT/bllvm-protocol-target/$PROTOCOL_CACHE_KEY"
          
          echo "CARGO_CACHE_DIR=$CARGO_CACHE_DIR" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$TARGET_CACHE_DIR" >> $GITHUB_ENV
          echo "CONSENSUS_TARGET_DIR=$CONSENSUS_TARGET_DIR" >> $GITHUB_ENV
          echo "PROTOCOL_TARGET_DIR=$PROTOCOL_TARGET_DIR" >> $GITHUB_ENV
          
          echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "consensus-cache-key=$CONSENSUS_CACHE_KEY" >> $GITHUB_OUTPUT
          echo "protocol-cache-key=$PROTOCOL_CACHE_KEY" >> $GITHUB_OUTPUT
          
          mkdir -p "$CARGO_CACHE_DIR"/{registry,git} "$TARGET_CACHE_DIR" "$CONSENSUS_TARGET_DIR" "$PROTOCOL_TARGET_DIR"
      
      - name: Cleanup temp dependencies
        if: always()
        run: |
          # Remove temp directories to prevent them from being used by other jobs
          rm -rf _temp-protocol-engine _temp-consensus-proof
          # Also clean up any existing parent directory dependencies (from previous runs)
          if [ -d "../bllvm-protocol" ]; then rm -rf ../bllvm-protocol; fi
          if [ -d "../bllvm-consensus" ]; then rm -rf ../bllvm-consensus; fi
          
          echo "  - Main: ${CACHE_KEY:0:16}..."
          echo "  - Consensus: ${CONSENSUS_CACHE_KEY:0:16}..."
          echo "  - Protocol: ${PROTOCOL_CACHE_KEY:0:16}..."

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0

  test:
    name: Test
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]'))) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.skip_tests != 'true')
    steps:
      - uses: actions/checkout@v4
      
      - name: Cleanup any leftover dependency directories
        run: |
          # Remove any leftover dependency directories from previous jobs
          if [ -d "../bllvm-protocol" ]; then rm -rf ../bllvm-protocol; fi
          if [ -d "../bllvm-consensus" ]; then rm -rf ../bllvm-consensus; fi
          # Also remove any .cargo/config.toml that might have been left behind
          if [ -f ".cargo/config.toml" ]; then rm -f .cargo/config.toml; fi
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$CACHE_ROOT/target/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          else
            echo "üíø No Cargo registry cache found"
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          else
            echo "üíø No Cargo git cache found"
          fi
      
      - name: Restore target
        run: |
          if [ -d "$TARGET_CACHE_DIR" ] && [ "$(ls -A $TARGET_CACHE_DIR 2>/dev/null)" ]; then
            rsync -a --delete "$TARGET_CACHE_DIR/" ./target/ || true
          else
            echo "üíø No target cache found, will build from scratch"
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Run tests
        run: |
          # Run tests only (no coverage) for fast PR feedback
          # Coverage runs separately in coverage.yml workflow
          cargo test --all-features --verbose
      
      - name: Cache registry
        if: always()
        run: |
          if [ -d "$HOME/.cargo/registry" ] && [ "$CARGO_CACHE_DIR" != "" ]; then
            rsync -a --delete "$HOME/.cargo/registry/" "$CARGO_CACHE_DIR/registry/" || true
          fi
      
      - name: Cache git
        if: always()
        run: |
          if [ -d "$HOME/.cargo/git" ] && [ "$CARGO_CACHE_DIR" != "" ]; then
            rsync -a --delete "$HOME/.cargo/git/" "$CARGO_CACHE_DIR/git/" || true
          fi
      
      - name: Cache target
        if: always()
        run: |
          if [ -d "./target" ] && [ "$TARGET_CACHE_DIR" != "" ]; then
            rsync -a --delete ./target/ "$TARGET_CACHE_DIR/" || true
          fi
      
      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up old caches..."
          CACHE_ROOT="/tmp/runner-cache"
          # Keep last 5 Cargo caches
          find "$CACHE_ROOT/cargo" -maxdepth 1 -type d -mtime +1 2>/dev/null | head -n -5 | xargs rm -rf 2>/dev/null || true
          # Keep last 3 target caches (larger)
          find "$CACHE_ROOT/target" -maxdepth 1 -type d -mtime +1 2>/dev/null | head -n -3 | xargs rm -rf 2>/dev/null || true

  clippy:
    name: Clippy
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]'))) &&
      ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_tests != 'true' }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$CACHE_ROOT/target/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
          components: clippy
      
      - name: Run clippy
        run: cargo clippy --lib --bins -- -D warnings

  verify:
    name: Verify
    needs: setup
    runs-on: [self-hosted, Linux, X64, perf]
    timeout-minutes: 360  # 6 hours for all proofs
    outputs:
      proof_tier: ${{ steps.set_tier_output.outputs.tier }}
      ami_id: ${{ secrets.KANI_RUNNER_AMI_ID }}
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]')))
      # Note: Strong tier ALWAYS runs (cannot be skipped)
      # Other tiers only run when manually triggered via workflow_dispatch
    steps:
      - uses: actions/checkout@v4
      
      - name: Checkout bllvm-protocol dependency
        uses: actions/checkout@v4
        with:
          repository: BTCDecoded/bllvm-protocol
          path: _temp-protocol-engine
      
      - name: Checkout consensus
        uses: actions/checkout@v4
        with:
          repository: BTCDecoded/bllvm-consensus
          path: _temp-consensus-proof
      
      - name: Move dependencies to parent directory
        run: |
          if [ -d "../bllvm-protocol" ]; then rm -rf ../bllvm-protocol; fi
          if [ -d "../bllvm-consensus" ]; then rm -rf ../bllvm-consensus; fi
          mv _temp-protocol-engine ../bllvm-protocol
          mv _temp-consensus-proof ../bllvm-consensus
      
      - name: Setup local dependencies for build
        run: |
          mkdir -p .cargo
          cat > .cargo/config.toml << EOF
          [patch.crates-io]
          bllvm-protocol = { path = "../bllvm-protocol" }
          bllvm-consensus = { path = "../bllvm-consensus" }
          EOF
          echo "‚úÖ Created .cargo/config.toml for local dependency builds"
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Verify Kani is available
        run: |
          echo "Checking for Kani model checker..."
          # Check if kani is available (should be pre-installed on runner)
          if command -v kani &> /dev/null; then
            echo "‚úÖ Found kani command: $(which kani)"
            kani --version || echo "Version check failed, but kani exists"
          elif command -v cargo &> /dev/null && cargo kani --version &> /dev/null; then
            echo "‚úÖ Found cargo kani subcommand"
            cargo kani --version
          else
            echo "‚ùå Kani not found on runner"
            echo "PATH: $PATH"
            echo "Please ensure Kani is installed on the runner"
            echo "Install with: curl -fsSL https://model-checking.github.io/kani/install.sh | sh -s -- -y"
            exit 1
          fi
      
      - name: Determine proof tier
        id: proof_tier
        run: |
          # Strong tier ALWAYS runs (critical node proofs)
          # Other tiers only run when manually triggered via workflow_dispatch
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.run_proof_tier }}" ]; then
            # Manual trigger: Use specified tier
            TIER="${{ github.event.inputs.run_proof_tier }}"
            echo "tier=$TIER" >> $GITHUB_OUTPUT
            case "$TIER" in
              fast)
                echo "description=Fast tier (unwind <= 3)" >> $GITHUB_OUTPUT
                echo "unwind_max=3" >> $GITHUB_OUTPUT
                ;;
              fast_medium)
                echo "description=Fast + Medium tier (unwind <= 9)" >> $GITHUB_OUTPUT
                echo "unwind_max=9" >> $GITHUB_OUTPUT
                ;;
              all)
                echo "description=All proofs (all unwind bounds)" >> $GITHUB_OUTPUT
                echo "unwind_max=999" >> $GITHUB_OUTPUT
                ;;
              *)
                echo "tier=" >> $GITHUB_OUTPUT
                echo "description=No additional tier" >> $GITHUB_OUTPUT
                ;;
            esac
          else
            # Automatic runs: No additional tier (strong tier only)
            echo "tier=" >> $GITHUB_OUTPUT
            echo "description=Strong tier only (no additional tier)" >> $GITHUB_OUTPUT
          fi
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Additional tier: ${{ steps.proof_tier.outputs.tier }}"
          echo "Description: ${{ steps.proof_tier.outputs.description }}"
      
      - name: Run Kani proofs (Strong tier - ALWAYS, cannot be skipped)
        run: |
          echo "üîí Running Kani proofs - STRONG TIER (critical node proofs)..."
          echo "These proofs verify the minimum set for 'formally verified' node status"
          echo "Note: Running with 3 parallel jobs (strong tier is small, mostly fast proofs)"
          # Get list of strong tier proofs
          STRONG_PROOFS=$(python3 scripts/get_proofs_by_tier.py strong)
          PROOF_COUNT=$(echo "$STRONG_PROOFS" | wc -w)
          echo "Found $PROOF_COUNT strong tier proofs to run"
          if [ "$PROOF_COUNT" -eq 0 ]; then
            echo "‚ùå No strong tier proofs found! This should never happen."
            exit 1
          fi
          TEMP_OUTPUT=$(mktemp)
          KANI_OUTPUT_FILE="kani_strong_output.txt"
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Build harness filter arguments
          HARNESS_ARGS=""
          for proof in $STRONG_PROOFS; do
            HARNESS_ARGS="$HARNESS_ARGS --harness $proof"
          done
          cargo kani --features verify --output-format terse --solver cadical --jobs 3 $HARNESS_ARGS 2>&1 | tee "$KANI_OUTPUT_FILE" | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            if [ $EXIT_CODE -eq 143 ]; then
              echo "‚ö†Ô∏è  Strong tier Kani proofs were terminated (exit code 143 = SIGTERM)"
              echo "This usually means the job timed out or was killed due to resource limits"
              echo "Strong tier proofs are critical - they must pass for node correctness"
              exit $EXIT_CODE
            else
              echo "‚ùå Strong tier Kani proofs failed (exit code: $EXIT_CODE)"
              echo "CRITICAL: Strong tier proofs verify core node operations"
              echo "Any failure here indicates a potential node correctness bug"
              exit $EXIT_CODE
            fi
          fi
          echo "‚úÖ Strong tier proofs verified successfully"
          # Hash the Kani output for attestation
          KANI_OUTPUT_HASH=$(sha256sum "$KANI_OUTPUT_FILE" | cut -d' ' -f1)
          echo "kani_strong_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_ENV
          echo "kani_strong_verified=true" >> $GITHUB_ENV
          echo "kani_strong_proofs=$PROOF_COUNT" >> $GITHUB_ENV
          echo "Kani strong tier output hash: $KANI_OUTPUT_HASH"
      
      - name: Upload Kani output for attestation (Strong tier)
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: kani-strong-attestation-data
          path: kani_strong_output.txt
          retention-days: 90
      
      - name: Run Kani proofs (Fast - manual only)
        if: steps.proof_tier.outputs.tier == 'fast'
        run: |
          echo "‚ö° Running Kani proofs - Fast tier (unwind <= 3)..."
          echo "Note: Strong tier already ran above. This runs additional fast proofs."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          # Get list of fast proofs (strong tier excluded automatically)
          FAST_PROOFS=$(python3 scripts/get_proofs_by_tier.py fast)
          PROOF_COUNT=$(echo "$FAST_PROOFS" | wc -w)
          echo "Found $PROOF_COUNT fast proofs to run (strong tier excluded)"
          if [ "$PROOF_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è  No additional fast proofs found (all may be in strong tier)"
            exit 0
          fi
          TEMP_OUTPUT=$(mktemp)
          KANI_OUTPUT_FILE="kani_output.txt"
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Build harness filter arguments
          HARNESS_ARGS=""
          for proof in $FAST_PROOFS; do
            HARNESS_ARGS="$HARNESS_ARGS --harness $proof"
          done
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 $HARNESS_ARGS 2>&1 | tee "$KANI_OUTPUT_FILE" | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            if [ $EXIT_CODE -eq 143 ]; then
              echo "‚ö†Ô∏è  Fast Kani proofs were terminated (exit code 143 = SIGTERM)"
              echo "This usually means the job timed out or was killed due to resource limits"
              echo "Consider running proofs in smaller batches or increasing timeout"
              exit $EXIT_CODE
            else
              echo "‚ùå Fast Kani proofs failed (exit code: $EXIT_CODE)"
              exit $EXIT_CODE
            fi
          fi
          echo "‚úÖ Fast proofs verified successfully"
          # Hash the Kani output for attestation (only on main branch)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            KANI_OUTPUT_HASH=$(sha256sum "$KANI_OUTPUT_FILE" | cut -d' ' -f1)
            echo "kani_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_ENV
            echo "kani_verified=true" >> $GITHUB_ENV
            echo "kani_proofs=$PROOF_COUNT" >> $GITHUB_ENV
            echo "Kani output hash: $KANI_OUTPUT_HASH"
          fi
      
      - name: Upload Kani output for attestation (Fast)
        if: steps.proof_tier.outputs.tier == 'fast' && github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: kani-attestation-data
          path: kani_output.txt
          retention-days: 90
      
      - name: Set proof tier output
        id: set_tier_output
        run: |
          echo "tier=${{ steps.proof_tier.outputs.tier }}" >> $GITHUB_OUTPUT

  provision-spot-runner:
    name: Provision Spot Runner
    needs: [verify]
    if: |
      needs.verify.outputs.proof_tier == 'fast_medium' ||
      needs.verify.outputs.proof_tier == 'all'
    uses: BTCDecoded/blvm/.github/workflows/provision-spot-runner.yml@main
    with:
      repo_name: blvm-node
      ami_id: ${{ needs.verify.outputs.ami_id }}
      instance_type: c6i.4xlarge
      runner_labels: 'self-hosted, Linux, X64, spot, kani'
      workload_type: kani
    secrets:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      AWS_SUBNET_ID: ${{ secrets.AWS_SUBNET_ID }}
      AWS_SECURITY_GROUP_ID: ${{ secrets.AWS_SECURITY_GROUP_ID }}

  verify-medium-slow:
    name: Verify (Medium + Slow Proofs on Spot Runner)
    needs: [verify, provision-spot-runner]
    runs-on: [self-hosted, Linux, X64, spot, kani]
    timeout-minutes: 360  # 6 hours for medium + slow proofs
    if: |
      needs.verify.outputs.proof_tier == 'fast_medium' ||
      needs.verify.outputs.proof_tier == 'all'
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Verify Kani is available
        run: |
          if command -v kani &> /dev/null; then
            echo "‚úÖ Found kani command: $(which kani)"
            kani --version
          else
            echo "‚ùå Kani not found on runner"
            exit 1
          fi
      
      - name: Run Kani proofs (Fast + Medium on Spot Runner)
        if: needs.verify.outputs.proof_tier == 'fast_medium'
        run: |
          echo "üîç Running Kani proofs - Fast + Medium tier (unwind <= 9) on spot runner..."
          echo "Note: Strong tier already ran on regular runner. This runs additional fast + medium proofs."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          # Get list of fast + medium proofs (strong tier excluded automatically)
          FAST_MEDIUM_PROOFS=$(python3 scripts/get_proofs_by_tier.py fast_medium)
          PROOF_COUNT=$(echo "$FAST_MEDIUM_PROOFS" | wc -w)
          echo "Found $PROOF_COUNT fast + medium proofs to run (strong tier excluded)"
          if [ "$PROOF_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è  No additional fast + medium proofs found (all may be in strong tier)"
            exit 0
          fi
          TEMP_OUTPUT=$(mktemp)
          KANI_OUTPUT_FILE="kani_spot_output.txt"
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Build harness filter arguments
          HARNESS_ARGS=""
          for proof in $FAST_MEDIUM_PROOFS; do
            HARNESS_ARGS="$HARNESS_ARGS --harness $proof"
          done
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 $HARNESS_ARGS 2>&1 | tee "$KANI_OUTPUT_FILE" | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            if [ $EXIT_CODE -eq 143 ]; then
              echo "‚ö†Ô∏è  Fast + Medium Kani proofs were terminated (exit code 143 = SIGTERM)"
              echo "This usually means the job timed out or was killed due to resource limits"
              echo "Consider running proofs in smaller batches or increasing timeout"
              exit $EXIT_CODE
            else
              echo "‚ùå Fast + Medium Kani proofs failed (exit code: $EXIT_CODE)"
              exit $EXIT_CODE
            fi
          fi
          echo "‚úÖ Fast + Medium proofs verified successfully on spot runner"
          # Hash the Kani output for attestation (only on main branch)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            KANI_OUTPUT_HASH=$(sha256sum "$KANI_OUTPUT_FILE" | cut -d' ' -f1)
            echo "kani_spot_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_ENV
            echo "kani_spot_verified=true" >> $GITHUB_ENV
            echo "kani_spot_proofs=$PROOF_COUNT" >> $GITHUB_ENV
            echo "Kani spot runner output hash: $KANI_OUTPUT_HASH"
          fi
      
      - name: Run Kani proofs (All on Spot Runner)
        if: needs.verify.outputs.proof_tier == 'all'
        timeout-minutes: 360  # 6 hours - all proofs can take 4-6 hours
        run: |
          echo "üêå Running Kani proofs - All tier (all unwind bounds) on spot runner..."
          echo "Note: Strong tier already ran on regular runner. This runs all remaining proofs."
          echo "Note: Running with minimal parallelism (2 jobs) to avoid OOM"
          echo "This includes slow proofs (unwind >= 10) which take significantly longer"
          echo "Expected duration: 4-6 hours for all proofs"
          echo "Job timeout: 360 minutes (6 hours)"
          # Get all proofs except strong tier
          # This means getting slow tier (unwind >= 10) plus any medium not in strong
          SLOW_PROOFS=$(python3 scripts/get_proofs_by_tier.py slow)
          FAST_MEDIUM_PROOFS=$(python3 scripts/get_proofs_by_tier.py fast_medium)
          PROOFS="$SLOW_PROOFS $FAST_MEDIUM_PROOFS"
          PROOF_COUNT=$(echo "$PROOFS" | wc -w)
          echo "Found $PROOF_COUNT proofs to run (all unwind bounds, strong tier excluded)"
          if [ "$PROOF_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è  No additional proofs found (all may be in strong tier)"
            exit 0
          fi
          TEMP_OUTPUT=$(mktemp)
          KANI_OUTPUT_FILE="kani_spot_output.txt"
          trap "rm -f $TEMP_OUTPUT" EXIT
          set +e
          # Build harness filter arguments
          HARNESS_ARGS=""
          for proof in $PROOFS; do
            HARNESS_ARGS="$HARNESS_ARGS --harness $proof"
          done
          cargo kani --features verify --output-format terse --solver cadical --jobs 2 $HARNESS_ARGS 2>&1 | tee "$KANI_OUTPUT_FILE" | grep -v "aborting path on assume(false)" | tee "$TEMP_OUTPUT"
          EXIT_CODE=${PIPESTATUS[0]}
          set -e
          if [ $EXIT_CODE -ne 0 ]; then
            if [ $EXIT_CODE -eq 143 ]; then
              echo "‚ö†Ô∏è  All Kani proofs were terminated (exit code 143 = SIGTERM)"
              echo "This usually means the job timed out or was killed due to resource limits"
              echo "The 'all' tier with all proofs can take 4-6 hours to complete"
              echo "Consider:"
              echo "  1. Increasing the job timeout (currently 360 minutes)"
              echo "  2. Running proofs in smaller batches"
              echo "  3. Using a runner with more memory/CPU"
              exit $EXIT_CODE
            else
              echo "‚ùå All Kani proofs failed (exit code: $EXIT_CODE)"
              echo "This is critical for node correctness - review proofs before release"
              exit $EXIT_CODE
            fi
          fi
          echo "‚úÖ All Kani proofs verified successfully on spot runner"
          # Hash the Kani output for attestation (only on main branch)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            KANI_OUTPUT_HASH=$(sha256sum "$KANI_OUTPUT_FILE" | cut -d' ' -f1)
            echo "kani_spot_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_ENV
            echo "kani_spot_verified=true" >> $GITHUB_ENV
            echo "kani_spot_proofs=$PROOF_COUNT" >> $GITHUB_ENV
            echo "Kani spot runner output hash: $KANI_OUTPUT_HASH"
          fi
      
      - name: Upload Kani output for attestation (Spot Runner)
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: kani-spot-attestation-data
          path: kani_spot_output.txt
          retention-days: 90

  cleanup-spot-runner:
    name: Cleanup Spot Runner
    needs: [verify-medium-slow]
    if: always()
    runs-on: [self-hosted, Linux, X64, builds]
    steps:
      - name: Stop EC2 Runner
        uses: machulav/ec2-github-runner@v2
        with:
          mode: stop
          github-token: ${{ secrets.GITHUB_TOKEN }}
          label: ${{ needs.provision-spot-runner.outputs.runner_label }}

  fmt:
    name: Format
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]'))) &&
      ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_tests != 'true' }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
          components: rustfmt
      
      - name: Check formatting
        run: cargo fmt -- --check

  docs:
    name: Docs
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]'))) &&
      ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.skip_tests != 'true' }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Build docs
        run: cargo doc --no-deps
      
      - name: Check docs
        run: cargo doc --no-deps --document-private-items

  security:
    name: Security
    needs: setup
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]')))
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Install cargo-audit
        run: |
          # Ensure cargo bin is in PATH (fixes exit code 127)
          export PATH="$HOME/.cargo/bin:$PATH"
          cargo install cargo-audit --version 0.21.0 --locked
      
      - name: Run security audit
        run: |
          # Ignore vulnerabilities in optional iroh-net feature dependencies
          # These are transitive dependencies that can't be easily fixed without
          # updating iroh-net to 0.28+ (deprecated, requires API changes)
          # See Cargo.toml security note for details
          cargo audit --ignore RUSTSEC-2024-0421 --ignore RUSTSEC-2025-0009 --ignore RUSTSEC-2023-0071

  build:
    name: Build
    needs: 
      - setup
      - test
      - clippy
      - fmt
      - docs
      - security
      - verify
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      always() &&
      needs.setup.result == 'success' &&
      (github.event_name == 'push' || github.event_name == 'release' || github.event_name == 'repository_dispatch' || github.event_name == 'workflow_dispatch') &&
      (github.event_name != 'push' || github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]'))) &&
      ((github.event_name == 'workflow_dispatch' && github.event.inputs.skip_tests == 'true') ||
       (needs.test.result == 'success' && needs.clippy.result == 'success' && 
        needs.fmt.result == 'success' && needs.docs.result == 'success' && 
        needs.security.result == 'success')) &&
      (needs.verify.result == 'skipped' || needs.verify.result == 'success')
    steps:
      - uses: actions/checkout@v4
      
      - name: Cache
        run: |
          CACHE_ROOT="/tmp/runner-cache"
          CACHE_KEY="${{ needs.setup.outputs.cache-key }}"
          
          echo "CARGO_CACHE_DIR=$CACHE_ROOT/cargo/$CACHE_KEY" >> $GITHUB_ENV
          echo "TARGET_CACHE_DIR=$CACHE_ROOT/target/$CACHE_KEY" >> $GITHUB_ENV
      
      - name: Restore registry
        run: |
          if [ -d "$CARGO_CACHE_DIR/registry" ] && [ "$(ls -A $CARGO_CACHE_DIR/registry 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/registry"
            rsync -a --delete "$CARGO_CACHE_DIR/registry/" "$HOME/.cargo/registry/" || true
          fi
      
      - name: Restore git
        run: |
          if [ -d "$CARGO_CACHE_DIR/git" ] && [ "$(ls -A $CARGO_CACHE_DIR/git 2>/dev/null)" ]; then
            mkdir -p "$HOME/.cargo/git"
            rsync -a --delete "$CARGO_CACHE_DIR/git/" "$HOME/.cargo/git/" || true
          fi
      
      - name: Restore target
        run: |
          if [ -d "$TARGET_CACHE_DIR" ] && [ "$(ls -A $TARGET_CACHE_DIR 2>/dev/null)" ]; then
            rsync -a --delete "$TARGET_CACHE_DIR/" ./target/ || true
          fi
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Build
        run: cargo build --release
      
      - name: Build tests
        run: cargo test --no-run --release --all-features
      
      - name: Cache target
        if: always()
        run: |
          if [ -d "./target" ] && [ "$TARGET_CACHE_DIR" != "" ]; then
            rsync -a --delete ./target/ "$TARGET_CACHE_DIR/" || true
          fi

  release:
    name: Release
    needs: [build, test, clippy, fmt, docs, security]
    runs-on: [self-hosted, Linux, X64, builds]
    if: |
      always() &&
      needs.build.result == 'success' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch') &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') &&
      (github.event.head_commit == null || 
       (!contains(github.event.head_commit.message, '[skip ci]') &&
        !contains(github.event.head_commit.message, '[ci skip]') &&
        !contains(github.event.head_commit.message, '[no ci]') &&
        !contains(github.event.head_commit.message, '[skip release]'))) &&
      ((github.event_name == 'workflow_dispatch' && github.event.inputs.skip_tests == 'true') ||
       (needs.test.result == 'success' && needs.clippy.result == 'success' && 
        needs.fmt.result == 'success' && needs.docs.result == 'success' && 
        needs.security.result == 'success'))
    permissions:
      contents: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: 1.88.0
      
      - name: Determine version
        id: version
        run: |
          # Auto-increment patch version from Cargo.toml
          # Extract only the package version (first version = after [package])
          CURRENT=$(grep -A 10 '^\[package\]' Cargo.toml | grep '^version = ' | head -1 | sed -E 's/^version = "([^"]+)".*/\1/')
          if [ -z "$CURRENT" ]; then
            echo "‚ùå Could not determine current version from Cargo.toml"
            echo "Debug: Looking for version in [package] section"
            grep -A 10 '^\[package\]' Cargo.toml | head -10
            exit 1
          fi
          
          echo "Current version: ${CURRENT}"
          
          # Validate version format (should be X.Y.Z)
          if ! echo "$CURRENT" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "‚ùå Invalid version format: ${CURRENT} (expected X.Y.Z)"
            exit 1
          fi
          
          # Increment patch version (X.Y.Z -> X.Y.(Z+1))
          MAJOR=$(echo "$CURRENT" | cut -d. -f1)
          MINOR=$(echo "$CURRENT" | cut -d. -f2)
          PATCH=$(echo "$CURRENT" | cut -d. -f3)
          
          # Validate components are numeric
          if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]] || ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Version components must be numeric: ${MAJOR}.${MINOR}.${PATCH}"
            exit 1
          fi
          
          PATCH=$((PATCH + 1))
          VERSION="${MAJOR}.${MINOR}.${PATCH}"
          
          # Check if version already exists and increment until we find a free one
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          MAX_ATTEMPTS=10
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            echo "Checking if ${CRATE_NAME} v${VERSION} already exists on crates.io..."
            
            # Update cargo index first to ensure we have latest data
            cargo update --dry-run 2>/dev/null || true
            
            VERSION_EXISTS="false"
            
            # Method 1: Check using cargo search with updated index (most reliable for cargo's view)
            CARGO_SEARCH_OUTPUT=$(cargo search "$CRATE_NAME" --limit 100 2>/dev/null || echo "")
            if echo "$CARGO_SEARCH_OUTPUT" | grep -qE "\"${CRATE_NAME}\".*\"${VERSION}\""; then
              VERSION_EXISTS="true"
              echo "Found via cargo search (with updated index)"
            else
              # Method 2: Check using crates.io API
              API_RESPONSE=$(curl -s --max-time 10 "https://crates.io/api/v1/crates/${CRATE_NAME}/versions" 2>/dev/null || echo "")
              
              if [ -n "$API_RESPONSE" ] && ! echo "$API_RESPONSE" | grep -q '"detail"'; then
                # Parse JSON to check if version exists
                if command -v jq &> /dev/null; then
                  EXISTS_CHECK=$(echo "$API_RESPONSE" | jq -r ".versions[] | select(.num == \"${VERSION}\") | .num" | head -1)
                  if [ "$EXISTS_CHECK" = "$VERSION" ]; then
                    VERSION_EXISTS="true"
                    echo "Found via crates.io API"
                  fi
                else
                  # Fallback: grep for version in JSON
                  if echo "$API_RESPONSE" | grep -q "\"num\":\"${VERSION}\""; then
                    VERSION_EXISTS="true"
                    echo "Found via crates.io API (grep)"
                  fi
                fi
              fi
              
              # Method 3: If still not found, try a temporary Cargo.toml update and dry-run check
              # This uses cargo's index directly (same as cargo publish)
              if [ "$VERSION_EXISTS" = "false" ]; then
                # Save original Cargo.toml
                cp Cargo.toml Cargo.toml.bak
                # Temporarily update version for dry-run check
                sed -i "s/^version = \".*\"/version = \"${VERSION}\"/" Cargo.toml
                DRY_RUN_OUTPUT=$(cargo publish --dry-run --allow-dirty 2>&1 || true)
                # Restore original Cargo.toml
                mv Cargo.toml.bak Cargo.toml
                
                if echo "$DRY_RUN_OUTPUT" | grep -qiE "(already exists|already been uploaded|already exists on crates.io)"; then
                  VERSION_EXISTS="true"
                  echo "Found via cargo publish dry-run (cargo index check)"
                fi
              fi
            fi
            
            if [ "$VERSION_EXISTS" = "true" ]; then
              echo "‚ö†Ô∏è  Version ${VERSION} already exists, incrementing..."
              MAJOR=$(echo "$VERSION" | cut -d. -f1)
              MINOR=$(echo "$VERSION" | cut -d. -f2)
              PATCH=$(echo "$VERSION" | cut -d. -f3)
              PATCH=$((PATCH + 1))
              VERSION="${MAJOR}.${MINOR}.${PATCH}"
              ATTEMPT=$((ATTEMPT + 1))
            else
              echo "‚úÖ Version ${VERSION} is available"
              break
            fi
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "‚ùå Failed to find available version after ${MAX_ATTEMPTS} attempts"
            exit 1
          fi
          
          # Add -unverified suffix if verification is skipped
          # Add -unverified suffix if verification OR tests are skipped
          # (untested counts as unverified)
          # Check if we're in workflow_dispatch mode
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SKIP_VERIFICATION="${{ github.event.inputs.skip_verification }}"
            SKIP_TESTS="${{ github.event.inputs.skip_tests }}"
          else
            SKIP_VERIFICATION="false"
            SKIP_TESTS="false"
          fi
          
          if [ "$SKIP_VERIFICATION" = "true" ] || [ "$SKIP_TESTS" = "true" ]; then
            VERSION_TAG="v${VERSION}-unverified"
            echo "‚ö†Ô∏è  Releasing UNVERIFIED version: ${VERSION_TAG}"
          else
            VERSION_TAG="v${VERSION}"
            echo "‚úÖ Releasing version: ${VERSION_TAG}"
          fi
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
      
      - name: Get latest bllvm-protocol version from crates.io
        id: protocol-version
        run: |
          PROTOCOL_VER=$(cargo search bllvm-protocol --limit 1 2>/dev/null | head -1 | sed -E 's/^bllvm-protocol = "([^"]+)".*/\1/' || echo "")
          if [ -z "$PROTOCOL_VER" ]; then
            echo "‚ùå bllvm-protocol not found on crates.io. It must be published first."
            exit 1
          fi
          echo "version=${PROTOCOL_VER}" >> $GITHUB_OUTPUT
          echo "Using bllvm-protocol version: ${PROTOCOL_VER}"
      
      - name: Prepare release Cargo.toml
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          PROTOCOL_VER="${{ steps.protocol-version.outputs.version }}"
          
          # Create a temporary Cargo.toml for release (don't modify source file)
          cp Cargo.toml Cargo.toml.release
          
          # Update version in the release copy
          sed -i "s/^version = \".*\"/version = \"${VERSION}\"/" Cargo.toml.release
          
          # Update bllvm-protocol dependency to use latest crates.io version
          sed -i 's|bllvm-protocol = { path = "\.\./bllvm-protocol"[^}]*}|bllvm-protocol = "'"${PROTOCOL_VER}"'"|g' Cargo.toml.release
          sed -i 's|^bllvm-protocol = "[^"]*"|bllvm-protocol = "'"${PROTOCOL_VER}"'"|g' Cargo.toml.release
          
          # Remove [patch.crates-io] section from release copy (use published crates)
          if grep -q "^\[patch\.crates-io\]" Cargo.toml.release; then
            PATCH_START=$(grep -n "^\[patch\.crates-io\]" Cargo.toml.release | cut -d: -f1)
            NEXT_SECTION=$(awk -v start="$PATCH_START" 'NR > start && /^\[/ {print NR; exit}' Cargo.toml.release)
            if [ -z "$NEXT_SECTION" ]; then
              sed -i "${PATCH_START},\$d" Cargo.toml.release
            else
              sed -i "${PATCH_START},$((NEXT_SECTION-1))d" Cargo.toml.release
            fi
            echo "‚úÖ Removed [patch.crates-io] section from release Cargo.toml"
          fi
          
          echo "Release Cargo.toml prepared:"
          echo "  version: ${VERSION}"
          echo "  bllvm-protocol: ${PROTOCOL_VER}"
          echo ""
          echo "Dependencies section:"
          grep -A 2 "^\[dependencies\]" Cargo.toml.release | head -5
          echo ""
          echo "Patch section check:"
          grep -A 5 "^\[patch\.crates-io\]" Cargo.toml.release || echo "  ‚úÖ [patch.crates-io] removed - using published crates"
      
      - name: Check for crates.io token
        run: |
          if [ -z "${CARGO_REGISTRY_TOKEN:-}" ]; then
            echo "‚ö†Ô∏è  CARGO_REGISTRY_TOKEN not set, skipping crate publication"
            echo "   Set CARGO_REGISTRY_TOKEN secret to enable crate publishing"
            exit 0
          fi
      
      - name: Configure cargo for crates.io
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo login "${CARGO_REGISTRY_TOKEN}"
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Use release Cargo.toml
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          # Replace Cargo.toml with the release version (temporary, just for this job)
          mv Cargo.toml.release Cargo.toml
          echo "‚úÖ Using release Cargo.toml (patch section removed, using published crates)"
      
      - name: Verify package
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo package --list
      
      - name: Dry-run publish
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo publish --dry-run
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Check if version already exists
        if: env.CARGO_REGISTRY_TOKEN != ''
        id: check-version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          
          echo "Checking if ${CRATE_NAME} v${VERSION} already exists on crates.io..."
          
          # Use crates.io API to check if version exists (more reliable than cargo search)
          # The API returns versions in the "versions" array
          API_RESPONSE=$(curl -s "https://crates.io/api/v1/crates/${CRATE_NAME}/versions" 2>/dev/null || echo "")
          
          if [ -z "$API_RESPONSE" ] || echo "$API_RESPONSE" | grep -q '"detail"'; then
            echo "‚ö†Ô∏è  Could not check crates.io API (crate may not exist yet), using cargo search as fallback"
            # Fallback to cargo search - check all versions
            if cargo search "$CRATE_NAME" --limit 100 2>/dev/null | grep -qE "\"${CRATE_NAME}\".*\"${VERSION}\""; then
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Version ${VERSION} already published for ${CRATE_NAME}"
            else
              echo "exists=false" >> $GITHUB_OUTPUT
              echo "‚úÖ Version ${VERSION} not yet published for ${CRATE_NAME}"
            fi
          else
            # Parse JSON to check if version exists (using jq if available, or grep as fallback)
            if command -v jq &> /dev/null; then
              VERSION_EXISTS=$(echo "$API_RESPONSE" | jq -r ".versions[] | select(.num == \"${VERSION}\") | .num" | head -1)
              if [ "$VERSION_EXISTS" = "$VERSION" ]; then
                echo "exists=true" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è  Version ${VERSION} already published for ${CRATE_NAME}"
              else
                echo "exists=false" >> $GITHUB_OUTPUT
                echo "‚úÖ Version ${VERSION} not yet published for ${CRATE_NAME}"
              fi
            else
              # Fallback: grep for version in JSON
              if echo "$API_RESPONSE" | grep -q "\"num\":\"${VERSION}\""; then
                echo "exists=true" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è  Version ${VERSION} already published for ${CRATE_NAME}"
              else
                echo "exists=false" >> $GITHUB_OUTPUT
                echo "‚úÖ Version ${VERSION} not yet published for ${CRATE_NAME}"
              fi
            fi
          fi
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Publish to crates.io
        if: env.CARGO_REGISTRY_TOKEN != ''
        id: publish
        continue-on-error: true
        run: |
          set +e
          VERSION="${{ steps.version.outputs.version }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          
          # Skip if version already exists
          if [ "${{ steps.check-version.outputs.exists }}" = "true" ]; then
            echo "‚ö†Ô∏è  Version ${VERSION} already exists on crates.io, skipping publish"
            echo "published=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Publishing ${CRATE_NAME} v${VERSION} to crates.io..."
          PUBLISH_OUTPUT=$(cargo publish --token "${CARGO_REGISTRY_TOKEN}" 2>&1)
          PUBLISH_EXIT_CODE=$?
          
          if [ $PUBLISH_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Successfully published ${CRATE_NAME} v${VERSION}"
            echo "published=true" >> $GITHUB_OUTPUT
            echo "Waiting 30 seconds for crates.io to index..."
            sleep 30
          else
            # Check if error is due to version already existing
            if echo "$PUBLISH_OUTPUT" | grep -q "already exists"; then
              echo "‚ö†Ô∏è  Version ${VERSION} already exists on crates.io (detected during publish)"
              echo "published=false" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "‚ùå Failed to publish ${CRATE_NAME} v${VERSION}"
              echo "Error output:"
              echo "$PUBLISH_OUTPUT"
              echo "published=false" >> $GITHUB_OUTPUT
              exit $PUBLISH_EXIT_CODE
            fi
          fi
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      
      - name: Verify published crate is available
        if: |
          env.CARGO_REGISTRY_TOKEN != '' &&
          steps.check-version.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          CRATE_NAME=$(grep -E '^name = ' Cargo.toml | sed -E 's/^name = "([^"]+)".*/\1/')
          echo "Verifying ${CRATE_NAME} v${VERSION} is available on crates.io..."
          
          # Try to fetch the crate info
          MAX_RETRIES=5
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if cargo search "$CRATE_NAME" --limit 1 2>/dev/null | grep -q "v${VERSION}"; then
              echo "‚úÖ ${CRATE_NAME} v${VERSION} is now available on crates.io"
              echo "üì¶ Crate page: https://crates.io/crates/${CRATE_NAME}/${VERSION}"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚è≥ Waiting for crates.io to index (attempt $RETRY_COUNT/$MAX_RETRIES)..."
                sleep 10
              else
                echo "‚ö†Ô∏è  ${CRATE_NAME} v${VERSION} not yet visible on crates.io (may take a few minutes)"
              fi
            fi
          done
      
      - name: Download attestation artifacts
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        uses: actions/download-artifact@v4
        with:
          pattern: '*-attestation-data'
          merge-multiple: true
          path: attestation-data
      
      - name: Collect build metadata for attestation
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        id: metadata
        run: |
          # Get toolchain versions
          RUSTC_VERSION=$(rustc --version | cut -d' ' -f2)
          CARGO_VERSION=$(cargo --version | cut -d' ' -f2)
          
          # Get CBMC version from Kani (if available)
          CBMC_VERSION=""
          if command -v kani &> /dev/null; then
            CBMC_VERSION=$(kani --version 2>&1 | grep -i cbmc | head -1 | sed -E 's/.*cbmc[^0-9]*([0-9.]+).*/\1/' || echo "")
          fi
          if [ -z "$CBMC_VERSION" ]; then
            CBMC_VERSION="unknown"
          fi
          
          # Hash Cargo.lock
          CARGO_LOCK_HASH=$(sha256sum Cargo.lock | cut -d' ' -f1)
          
          # Check if debug assertions are enabled (check Cargo.toml or build flags)
          DEBUG_ASSERTIONS="false"
          if grep -q "debug-assertions = true" Cargo.toml 2>/dev/null; then
            DEBUG_ASSERTIONS="true"
          fi
          
          # Extract Kani data from artifacts
          KANI_VERIFIED="false"
          KANI_PROOFS="0"
          KANI_OUTPUT_HASH=""
          KANI_STRONG_VERIFIED="false"
          KANI_STRONG_PROOFS="0"
          KANI_STRONG_OUTPUT_HASH=""
          
          # Strong tier (always runs)
          if [ -f "attestation-data/kani_strong_output.txt" ]; then
            KANI_STRONG_VERIFIED="true"
            KANI_STRONG_OUTPUT_HASH=$(sha256sum attestation-data/kani_strong_output.txt | cut -d' ' -f1)
            KANI_STRONG_PROOFS=$(grep -c "Checking harness" attestation-data/kani_strong_output.txt 2>/dev/null || echo "0")
            if [ "$KANI_STRONG_PROOFS" = "0" ]; then
              # Fallback: count strong tier proofs
              KANI_STRONG_PROOFS=$(python3 scripts/get_proofs_by_tier.py strong | wc -w)
            fi
          fi
          
          # Additional tier (manual only)
          if [ -f "attestation-data/kani_output.txt" ]; then
            KANI_VERIFIED="true"
            KANI_OUTPUT_HASH=$(sha256sum attestation-data/kani_output.txt | cut -d' ' -f1)
            # Count proofs from output (approximate)
            KANI_PROOFS=$(grep -c "Checking harness" attestation-data/kani_output.txt 2>/dev/null || echo "0")
            if [ "$KANI_PROOFS" = "0" ]; then
              # Fallback: count from tier
              KANI_PROOFS="0"
            fi
          fi
          
          # Total proofs = strong + additional
          TOTAL_KANI_PROOFS=$((KANI_STRONG_PROOFS + KANI_PROOFS))
          
          # Output all metadata
          echo "kani_strong_verified=$KANI_STRONG_VERIFIED" >> $GITHUB_OUTPUT
          echo "kani_strong_proofs=$KANI_STRONG_PROOFS" >> $GITHUB_OUTPUT
          echo "kani_strong_output_hash=$KANI_STRONG_OUTPUT_HASH" >> $GITHUB_OUTPUT
          echo "kani_verified=$KANI_VERIFIED" >> $GITHUB_OUTPUT
          echo "kani_proofs=$KANI_PROOFS" >> $GITHUB_OUTPUT
          echo "kani_output_hash=$KANI_OUTPUT_HASH" >> $GITHUB_OUTPUT
          echo "kani_total_proofs=$TOTAL_KANI_PROOFS" >> $GITHUB_OUTPUT
          echo "debug_assertions_enabled=$DEBUG_ASSERTIONS" >> $GITHUB_OUTPUT
          echo "rustc_version=$RUSTC_VERSION" >> $GITHUB_OUTPUT
          echo "cbmc_version=$CBMC_VERSION" >> $GITHUB_OUTPUT
          echo "cargo_version=$CARGO_VERSION" >> $GITHUB_OUTPUT
          echo "cargo_lock_hash=$CARGO_LOCK_HASH" >> $GITHUB_OUTPUT
          
          echo "üìã Build Metadata:"
          echo "  Kani strong tier verified: $KANI_STRONG_VERIFIED"
          echo "  Kani strong tier proofs: $KANI_STRONG_PROOFS"
          echo "  Kani strong tier output hash: $KANI_STRONG_OUTPUT_HASH"
          echo "  Kani additional tier verified: $KANI_VERIFIED"
          echo "  Kani additional tier proofs: $KANI_PROOFS"
          echo "  Kani additional tier output hash: $KANI_OUTPUT_HASH"
          echo "  Kani total proofs: $TOTAL_KANI_PROOFS"
          echo "  Debug assertions: $DEBUG_ASSERTIONS"
          echo "  rustc version: $RUSTC_VERSION"
          echo "  CBMC version: $CBMC_VERSION"
          echo "  cargo version: $CARGO_VERSION"
          echo "  Cargo.lock hash: $CARGO_LOCK_HASH"
      
      - name: Create build attestation
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        id: attestation
        run: |
          # Create predicate JSON file
          cat > predicate.json << EOF
          {
            "kani_strong_verified": ${{ steps.metadata.outputs.kani_strong_verified == 'true' && 'true' || 'false' }},
            "kani_strong_proofs": ${{ steps.metadata.outputs.kani_strong_proofs }},
            "kani_strong_output_hash": "${{ steps.metadata.outputs.kani_strong_output_hash }}",
            "kani_verified": ${{ steps.metadata.outputs.kani_verified == 'true' && 'true' || 'false' }},
            "kani_proofs": ${{ steps.metadata.outputs.kani_proofs }},
            "kani_output_hash": "${{ steps.metadata.outputs.kani_output_hash }}",
            "kani_total_proofs": ${{ steps.metadata.outputs.kani_total_proofs }},
            "debug_assertions_enabled": ${{ steps.metadata.outputs.debug_assertions_enabled == 'true' && 'true' || 'false' }},
            "rustc_version": "${{ steps.metadata.outputs.rustc_version }}",
            "cbmc_version": "${{ steps.metadata.outputs.cbmc_version }}",
            "cargo_version": "${{ steps.metadata.outputs.cargo_version }}",
            "cargo_lock_hash": "${{ steps.metadata.outputs.cargo_lock_hash }}"
          }
          EOF
          cat predicate.json
      
      - name: Upload build metadata
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        uses: actions/upload-artifact@v4
        with:
          name: build-metadata
          path: predicate.json
          retention-days: 365
      
      - name: Attest build provenance
        if: ${{ github.event_name != 'workflow_dispatch' || (github.event.inputs.skip_verification != 'true' && github.event.inputs.skip_tests != 'true') }}
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: "bllvm-node"
          subject-digest: "sha256:${{ steps.metadata.outputs.cargo_lock_hash }}"
          push-to-registry: false
          show-summary: true
      
      - name: Create git tag
        run: |
          VERSION_TAG="${{ steps.version.outputs.version_tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if tag already exists
          if git rev-parse "$VERSION_TAG" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Tag ${VERSION_TAG} already exists, skipping tag creation"
          else
            git tag -a "$VERSION_TAG" -m "Release ${VERSION_TAG}"
            git push origin "$VERSION_TAG"
            echo "‚úÖ Created and pushed tag ${VERSION_TAG}"
          fi
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version_tag }}
          name: Release ${{ steps.version.outputs.version_tag }}
          body: |
            ## ${{ steps.version.outputs.version_tag }}
            
            Automated release of bllvm-node.
            
            **Published to crates.io**: ${{ steps.publish.outputs.published == 'true' && '‚úÖ Yes' || (steps.check-version.outputs.exists == 'true' && '‚ö†Ô∏è  Already exists' || '‚ùå Failed or skipped') }}
            
            ### Changes
            See [commit history](https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }})
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

